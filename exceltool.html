<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tool2</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #ffffff;
            color: #000000;
            line-height: 1.6;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }
        code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 15px;
        }
        ul, ol {
            margin-bottom: 15px;
            padding-left: 20px;
        }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 0;
            padding-left: 15px;
            color: #666;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <div id="content">
        <!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è´¦å•è½¬æ¢å·¥å…·</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-hover: #30363d;
            --border-color: #30363d;
            --border-focus: #58a6ff;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.4);
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --transition: all 0.2s ease;
            --safe-area-bottom: env(safe-area-inset-bottom, 20px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding-bottom: var(--safe-area-bottom);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
        }

        header {
            text-align: center;
            margin-bottom: 24px;
            padding: 24px 16px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }

        header h1 {
            font-size: 2rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        header p {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            transition: var(--transition);
            min-width: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .card-title {
            font-size: 1.15rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title .icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent-blue);
            border-radius: var(--radius-sm);
            font-size: 16px;
        }

        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-md);
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            background: var(--bg-tertiary);
        }

        .upload-zone:active {
            background: var(--bg-hover);
        }

        .upload-zone .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }

        input[type="file"] {
            display: none;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .form-row {
            display: flex;
            gap: 16px;
            align-items: flex-end;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Improved inputs for touch targets */
        input[type="text"],
        input[type="number"],
        input[type="time"],
        select,
        textarea {
            width: 100%;
            padding: 12px 14px; /* Increased padding for touch */
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 16px; /* Prevent iOS zoom on focus */
            transition: var(--transition);
            appearance: none; /* Reset native appearance */
        }

        /* Custom arrow for selects */
        select {
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%238b949e' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 30px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.2);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 20px; /* Increased padding */
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            min-height: 44px; /* Touch target size */
            white-space: nowrap;
        }

        .btn-primary { background: var(--accent-blue); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-success { background: var(--accent-green); color: white; }
        .btn-danger { background: var(--accent-red); color: white; }
        
        .btn:active { transform: scale(0.98); }

        .btn-sm {
            padding: 8px 12px;
            font-size: 0.85rem;
            min-height: 36px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            max-height: 400px;
            background: var(--bg-primary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }

        th {
            background: var(--bg-tertiary);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .mapping-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .mapping-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 16px;
        }

        .mapping-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .mapping-target {
            font-weight: 600;
            color: var(--accent-blue);
            font-size: 1.1rem;
        }

        .mapping-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .tag {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            white-space: nowrap;
        }
        .tag-blue { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
        .tag-green { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
        .tag-orange { background: rgba(210, 153, 34, 0.2); color: var(--accent-orange); }
        .tag-purple { background: rgba(163, 113, 247, 0.2); color: var(--accent-purple); }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            margin-top: 16px;
            font-size: 0.9rem;
            flex-wrap: wrap;
            gap: 8px;
        }

        /* Combined Rules Mobile Optimization */
        .condition-item {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            background: var(--bg-secondary);
            padding: 8px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
        }
        
        .condition-item select, 
        .condition-item input {
            min-width: 0; /* Allow shrinking */
            flex: 1 1 120px; /* Grow and shrink, basis 120px */
        }
        
        .condition-item .btn {
            flex: 0 0 auto;
            min-width: auto;
        }

        /* Config Actions */
        .config-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .preset-select {
            flex-grow: 1;
            min-width: 200px;
        }

        /* Sticky Action Bar */
        .action-bar {
            position: sticky;
            bottom: 0;
            background: var(--bg-secondary);
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 24px -24px -24px;
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
            z-index: 100;
        }

        /* Modal Mobile Optimization */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            backdrop-filter: blur(2px);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.95);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal-header {
            margin-bottom: 16px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 8px;
            margin: -8px;
        }

        /* Column Config Items */
        .column-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .column-item input {
            flex: 1;
            min-width: 120px;
        }

        .hidden { display: none !important; }

        /* ================= MOBILE SPECIFIC STYLES ================= */
        @media (max-width: 768px) {
            .container {
                padding: 12px;
                padding-bottom: 80px; /* Space for action bar */
            }

            header {
                padding: 20px 12px;
                margin-bottom: 16px;
            }
            
            header h1 {
                font-size: 1.5rem;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .card {
                padding: 16px;
                border-radius: var(--radius-md);
            }

            .mapping-body {
                grid-template-columns: 1fr;
            }

            /* Config Actions: Stack buttons vertically */
            .config-actions {
                flex-direction: column;
            }
            
            .config-actions > div {
                width: 100%;
                display: flex;
                flex-wrap: wrap;
            }

            .config-actions .btn {
                flex: 1;
                min-width: 120px; /* Ensure 2 per row mostly */
            }

            /* Form Row Stack */
            .form-row {
                flex-direction: column;
                gap: 12px;
            }

            /* Mapping Rules optimization */
            .combined-result {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .combined-result input {
                width: 100%;
            }

            /* Action Bar: Mobile Bottom Sheet style */
            .action-bar {
                flex-direction: column;
                gap: 12px;
                margin: 0 -12px -12px; /* Offset container padding */
                padding: 16px;
                padding-bottom: max(16px, var(--safe-area-bottom));
                border-radius: 16px 16px 0 0;
            }

            .action-bar > div {
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .action-bar .btn-group {
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr; /* Equal width buttons */
            }

            .action-bar .btn {
                padding: 10px 4px;
                font-size: 0.8rem;
                flex-direction: column;
                gap: 4px;
            }

            /* Modal: Full screen on mobile */
            .modal {
                width: 100%;
                height: 100%;
                max-height: 100%;
                border-radius: 0;
                padding-top: 50px; /* Space for close button if needed, or just header */
            }
            
            .rule-check-summary {
                flex-direction: column;
            }
            
            .rule-check-stat {
                padding: 8px;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
            
            .rule-check-stat .stat-value {
                font-size: 1.5rem;
                order: 2;
            }
            
            .file-info {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .file-info .btn {
                width: 100%;
                margin-top: 8px;
            }
        }
    </style>
    <!-- PRESET_CONFIG_START -->
    <script type="application/json" id="preset-config">
{
    "meituan-pixiu": {
        "name": "ç¾å›¢è´¦å• â†’ è²”è²…è®°è´¦",
        "skipRows": 16,
        "targetColumns": [
            {
                "name": "äº¤æ˜“æ—¥æœŸ",
                "defaultValue": ""
            },
            {
                "name": "æ”¶æ”¯ç±»å‹",
                "defaultValue": ""
            },
            {
                "name": "æ”¶æ”¯é¡¹ç›®",
                "defaultValue": ""
            },
            {
                "name": "é‡‘é¢",
                "defaultValue": ""
            },
            {
                "name": "è´¦æˆ·åç§°",
                "defaultValue": ""
            },
            {
                "name": "æ ‡ç­¾",
                "defaultValue": ""
            },
            {
                "name": "å¤‡æ³¨",
                "defaultValue": ""
            }
        ],
        "mappingRules": {
            "äº¤æ˜“æ—¥æœŸ": {
                "type": "date",
                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                "dateFormat": "YYYY-MM-DD"
            },
            "æ”¶æ”¯ç±»å‹": {
                "type": "valueMap",
                "sourceColumn": "æ”¶/æ”¯",
                "mappings": {
                    "æ”¯å‡º": "æ”¯å‡º",
                    "æ”¶å…¥": "æ”¶å…¥"
                }
            },
            "æ”¶æ”¯é¡¹ç›®": {
                "type": "combinedCondition",
                "sourceColumn": "è®¢å•æ ‡é¢˜",
                "combinedConditions": [
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "æ‰“è½¦,å¿«è½¦,æ›¹æ“,æ»´æ»´"
                            }
                        ],
                        "targetValue": "æ‰“è½¦"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "éª‘è¡Œ,å•è½¦"
                            }
                        ],
                        "targetValue": "è‡ªè¡Œè½¦"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "åœ°é“"
                            }
                        ],
                        "targetValue": "åœ°é“"
                    },
                    {
                        "conditions": [
                            {
                                "type": "timeRange",
                                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                                "startTime": "06:00",
                                "endTime": "10:00"
                            },
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "é¸­å¤´,å¯¿å¸,æ°¸å’Œå¤§ç‹,å¤è‚‰é¥­,å•äººé¤,ç±³çº¿,ç‚¸é¸¡,è€ä¹¡é¸¡,æ°´é¥º,é¢é¦†,é¢æ¡,é¤å…,é¤é¥®,æ¹˜èœ,å·èœ,ç²¤èœ,å¿«é¤,é¥­åº—,ç‰›è‚‰é¢,æ‹Œé¢,ç›–é¥­,ç‚’é¥­,ç‚’é¢,ç‚¹å¿ƒ,å°åƒ,å¤–å–,è‚¯å¾·åŸº,KFC,éº¦å½“åŠ³,ç¿ å¯Œæ¥¼,å—äº¬å¤§ç‰Œæ¡£,æµ·é²œ,åŒäººé¤,ä¼ ç»Ÿå°ç‚’,è‚‰èŸ¹ç…²,é¦™é”…,è¶…çº§ç¢—,æ©æ–½å®‹é¸­å­,ç‰›è‚‰åº—,ç¾å›¢ä¹°å•è®¢å•"
                            }
                        ],
                        "targetValue": "æ—©é¤"
                    },
                    {
                        "conditions": [
                            {
                                "type": "timeRange",
                                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                                "startTime": "10:30",
                                "endTime": "15:00"
                            },
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç³¯ç±³é¥­,é¾™è™¾,é¸­å¤´,å¯¿å¸,æ°¸å’Œå¤§ç‹,å¤è‚‰é¥­,å•äººé¤,ç±³çº¿,ç‚¸é¸¡,è€ä¹¡é¸¡,æ°´é¥º,é¢é¦†,é¢æ¡,é¤å…,é¤é¥®,æ¹˜èœ,å·èœ,ç²¤èœ,å¿«é¤,é¥­åº—,ç‰›è‚‰é¢,æ‹Œé¢,ç›–é¥­,ç‚’é¥­,ç‚’é¢,ç‚¹å¿ƒ,å°åƒ,å¤–å–,è‚¯å¾·åŸº,KFC,éº¦å½“åŠ³,ç¿ å¯Œæ¥¼,å—äº¬å¤§ç‰Œæ¡£,æµ·é²œ,åŒäººé¤,ä¼ ç»Ÿå°ç‚’,è‚‰èŸ¹ç…²,é¦™é”…,è¶…çº§ç¢—,æ©æ–½å®‹é¸­å­,ç‰›è‚‰åº—,ç¾å›¢ä¹°å•è®¢å•"
                            }
                        ],
                        "targetValue": "åˆé¤"
                    },
                    {
                        "conditions": [
                            {
                                "type": "timeRange",
                                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                                "startTime": "15:00",
                                "endTime": "21:00"
                            },
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç³¯ç±³é¥­,é¾™è™¾,é¸­å¤´,å¯¿å¸,æ°¸å’Œå¤§ç‹,å¤è‚‰é¥­,å•äººé¤,ç±³çº¿,ç‚¸é¸¡,è€ä¹¡é¸¡,æ°´é¥º,é¢é¦†,é¢æ¡,é¤å…,é¤é¥®,æ¹˜èœ,å·èœ,ç²¤èœ,å¿«é¤,é¥­åº—,ç‰›è‚‰é¢,æ‹Œé¢,ç›–é¥­,ç‚’é¥­,ç‚’é¢,ç‚¹å¿ƒ,å°åƒ,å¤–å–,è‚¯å¾·åŸº,KFC,éº¦å½“åŠ³,ç¿ å¯Œæ¥¼,å—äº¬å¤§ç‰Œæ¡£,æµ·é²œ,åŒäººé¤,ä¼ ç»Ÿå°ç‚’,è‚‰èŸ¹ç…²,é¦™é”…,è¶…çº§ç¢—,æ©æ–½å®‹é¸­å­,ç‰›è‚‰åº—,ç¾å›¢ä¹°å•è®¢å•,çƒ§çƒ¤,ç«é”…,ä¸²ä¸²"
                            }
                        ],
                        "targetValue": "æ™šé¤"
                    },
                    {
                        "conditions": [
                            {
                                "type": "timeRange",
                                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                                "startTime": "21:00",
                                "endTime": "23:59"
                            },
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç³¯ç±³é¥­,é¾™è™¾,é¸­å¤´,å¯¿å¸,æ°¸å’Œå¤§ç‹,å¤è‚‰é¥­,å•äººé¤,ç±³çº¿,ç‚¸é¸¡,è€ä¹¡é¸¡,æ°´é¥º,é¢é¦†,é¢æ¡,é¤å…,é¤é¥®,æ¹˜èœ,å·èœ,ç²¤èœ,å¿«é¤,é¥­åº—,ç‰›è‚‰é¢,æ‹Œé¢,ç›–é¥­,ç‚’é¥­,ç‚’é¢,ç‚¹å¿ƒ,å°åƒ,å¤–å–,è‚¯å¾·åŸº,KFC,éº¦å½“åŠ³,ç¿ å¯Œæ¥¼,å—äº¬å¤§ç‰Œæ¡£,æµ·é²œ,åŒäººé¤,ä¼ ç»Ÿå°ç‚’,è‚‰èŸ¹ç…²,é¦™é”…,è¶…çº§ç¢—,æ©æ–½å®‹é¸­å­,ç‰›è‚‰åº—,ç¾å›¢ä¹°å•è®¢å•,çƒ§çƒ¤,ç«é”…,ä¸²ä¸²"
                            }
                        ],
                        "targetValue": "å®µå¤œ"
                    },
                    {
                        "conditions": [
                            {
                                "type": "timeRange",
                                "sourceColumn": "äº¤æ˜“æˆåŠŸæ—¶é—´",
                                "startTime": "00:00",
                                "endTime": "06:00"
                            },
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç³¯ç±³é¥­,é¾™è™¾,é¸­å¤´,å¯¿å¸,æ°¸å’Œå¤§ç‹,å¤è‚‰é¥­,å•äººé¤,ç±³çº¿,ç‚¸é¸¡,è€ä¹¡é¸¡,æ°´é¥º,é¢é¦†,é¢æ¡,é¤å…,é¤é¥®,æ¹˜èœ,å·èœ,ç²¤èœ,å¿«é¤,é¥­åº—,ç‰›è‚‰é¢,æ‹Œé¢,ç›–é¥­,ç‚’é¥­,ç‚’é¢,ç‚¹å¿ƒ,å°åƒ,å¤–å–,è‚¯å¾·åŸº,KFC,éº¦å½“åŠ³,ç¿ å¯Œæ¥¼,å—äº¬å¤§ç‰Œæ¡£,æµ·é²œ,åŒäººé¤,ä¼ ç»Ÿå°ç‚’,è‚‰èŸ¹ç…²,é¦™é”…,è¶…çº§ç¢—,æ©æ–½å®‹é¸­å­,ç‰›è‚‰åº—,ç¾å›¢ä¹°å•è®¢å•,çƒ§çƒ¤,ç«é”…,ä¸²ä¸²"
                            }
                        ],
                        "targetValue": "å®µå¤œ"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "å’–å•¡,ç‘å¹¸,Luckin,æ˜Ÿå·´å…‹,Manner"
                            }
                        ],
                        "targetValue": "å’–å•¡"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "å¥¶èŒ¶,èŒ¶é¥®,å–œèŒ¶,èœœé›ª,å¤èŒ—,èŒ¶ç™¾é“,ä¹¦äº¦,ä¸€ç‚¹ç‚¹,COCO,ä¹ä¹èŒ¶,LELECHA,èŒ¶åŠè‹¦æŠ¹,å¥ˆé›ªçš„èŒ¶,çˆ·çˆ·ä¸æ³¡èŒ¶"
                            }
                        ],
                        "targetValue": "å¥¶èŒ¶"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "å°è±¡è¶…å¸‚,ç¾å›¢ä¹°èœ,èœ,è¶…å¸‚,ä¾¿åˆ©åº—"
                            }
                        ],
                        "targetValue": "å…¶ä»–æ‚é¡¹"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "è¯æˆ¿,è¯åº—,åŒ»é™¢,è¯Šæ‰€,æµ·ç‹æ˜Ÿè¾°,å®å½“å¿«è¯"
                            }
                        ],
                        "targetValue": "ä¸­è¥¿è¯"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç”µå½±"
                            }
                        ],
                        "targetValue": "ç”µå½±"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "KTV"
                            }
                        ],
                        "targetValue": "KTVå”±æ­Œ"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "æ¸¸æˆ"
                            }
                        ],
                        "targetValue": "æ¸¸æˆ"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç½‘å§,ç”µç«"
                            }
                        ],
                        "targetValue": "ç½‘å§"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "è¶³é“"
                            }
                        ],
                        "targetValue": "æ¨æ‹¿è¶³æŒ‰"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "å……ç”µ"
                            }
                        ],
                        "targetValue": "å……ç”µå®"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "æ°‘è¥æœºæ„ç”·æ€§å¥—é¤"
                            }
                        ],
                        "targetValue": "ä½“æ£€"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "é²œèŠ±åº—,ååˆ›ä¼˜å“,Appleæˆæƒä¸“è¥åº—"
                            }
                        ],
                        "targetValue": "ç¤¼ç‰©"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "ç”œå“"
                            }
                        ],
                        "targetValue": "ç”œå“"
                    },
                    {
                        "conditions": [
                            {
                                "type": "contains",
                                "sourceColumn": "è®¢å•æ ‡é¢˜",
                                "value": "å•†åŸè®¢å•"
                            }
                        ],
                        "targetValue": "å…¶ä»–æ‚é¡¹"
                    }
                ]
            },
            "é‡‘é¢": {
                "type": "amount",
                "sourceColumn": "å®ä»˜é‡‘é¢"
            },
            "è´¦æˆ·åç§°": {
                "type": "fuzzyMap",
                "sourceColumn": "æ”¯ä»˜æ–¹å¼",
                "fuzzyMappings": [
                    {
                        "contains": "å¾®ä¿¡",
                        "mapTo": "å¾®ä¿¡é›¶é’±"
                    },
                    {
                        "contains": "æ‹›å•†é“¶è¡Œ",
                        "mapTo": "æ‹›å•†ä¿¡ç”¨å¡"
                    },
                    {
                        "contains": "æ°‘ç”Ÿ",
                        "mapTo": "æ°‘ç”Ÿé“¶è¡Œä¿¡ç”¨å¡"
                    },
                    {
                        "contains": "æ”¯ä»˜å®",
                        "mapTo": "æ”¯ä»˜å®ä½™é¢"
                    },
                    {
                        "contains": "èŠ±å‘—",
                        "mapTo": "èŠ±å‘—"
                    },
                    {
                        "contains": "ç™½æ¡",
                        "mapTo": "ç™½æ¡"
                    }
                ]
            },
            "æ ‡ç­¾": {
                "type": "fixed",
                "fixedValue": "ç¾å›¢"
            },
            "å¤‡æ³¨": {
                "type": "direct",
                "sourceColumn": "è®¢å•æ ‡é¢˜"
            }
        }
    }
}
    </script>
    <!-- PRESET_CONFIG_END -->
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div class="container" id="main-container">
        <header>
            <h1>ğŸ“Š è´¦å•è½¬æ¢å·¥å…·</h1>
            <p>æ”¯æŒè‡ªå®šä¹‰æ˜ å°„è§„åˆ™ï¼Œè½»æ¾è½¬æ¢å„ç±»è´¦å•æ ¼å¼</p>
        </header>

        <!-- é…ç½®ç®¡ç†åŒºåŸŸ -->
        <div class="card" style="margin-bottom: 24px;">
            <div class="card-header">
                <div class="card-title">
                    <span class="icon">âš™ï¸</span>
                    é…ç½®æ–¹æ¡ˆ
                </div>
            </div>
            <div class="config-actions">
                <div style="display: flex; gap: 8px; flex: 1;">
                    <select id="presetSelect" class="preset-select" onchange="onPresetSelectChange()">
                        <option value="">-- é€‰æ‹©é…ç½®æ–¹æ¡ˆ --</option>
                    </select>
                    <button class="btn btn-primary" onclick="applySelectedPreset()" title="åº”ç”¨é€‰ä¸­çš„é…ç½®æ–¹æ¡ˆ">âœ“ åº”ç”¨</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-secondary" onclick="saveAsNewPreset()">â• å¦å­˜</button>
                    <button class="btn btn-secondary" onclick="renamePreset()">âœï¸ å‘½å</button>
                    <button class="btn btn-secondary" onclick="deletePreset()">ğŸ—‘ï¸ åˆ é™¤</button>
                    <button class="btn btn-secondary" onclick="exportConfig()">ğŸ“¤ å¯¼å‡º</button>
                    <button class="btn btn-secondary" onclick="importConfig()">ğŸ“¥ å¯¼å…¥</button>
                    <button class="btn btn-primary" onclick="saveRulesToHtml()">ğŸ’¾ ä¿å­˜HTML</button>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <!-- å·¦ä¾§ï¼šè¾“å…¥é…ç½® -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon">ğŸ“</span>
                        è¾“å…¥é…ç½®
                    </div>
                </div>

                <div class="upload-zone hidden" id="uploadZone">
                    <div class="upload-icon">ğŸ“„</div>
                    <p>ç‚¹å‡»é€‰æ‹©æˆ–æ‹–æ‹½ CSV æ–‡ä»¶</p>
                    <p class="hint">æ”¯æŒ .csv æ ¼å¼æ–‡ä»¶</p>
                </div>
                <!-- Separate button for mobile easier clicking if drag drop fails visually -->
                <button class="btn btn-primary btn-lg" id="mobileUploadBtn" style="display:none; width: 100%; margin-bottom: 16px;" onclick="document.getElementById('fileInput').click()">ğŸ“„ é€‰æ‹© CSV æ–‡ä»¶</button>
                <input type="file" id="fileInput" accept=".csv">

                <div id="fileInfo" class="file-info hidden">
                    <span class="file-icon">ğŸ“„</span>
                    <div class="file-details">
                        <div class="file-name" id="fileName"></div>
                        <div class="file-size" id="fileSize"></div>
                    </div>
                    <button class="btn btn-secondary btn-sm" onclick="clearFile()">æ¸…é™¤</button>
                </div>

                <div class="form-row" style="margin-top: 16px;">
                    <div class="form-group">
                        <label>è·³è¿‡è¡Œæ•°ï¼ˆè¡¨å¤´å‰ï¼‰</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="number" id="skipRows" value="0" min="0" onchange="parseSourceData()" style="flex: 1;">
                            <button class="btn btn-secondary" onclick="autoDetectHeader()" title="è‡ªåŠ¨æ£€æµ‹è¡¨å¤´è¡Œ">ğŸ” è‡ªåŠ¨</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>æ–‡ä»¶ç¼–ç </label>
                        <select id="fileEncoding" onchange="parseSourceData()">
                            <option value="UTF-8">UTF-8</option>
                            <option value="GBK">GBK</option>
                            <option value="GB2312">GB2312</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>æºæ•°æ®é¢„è§ˆ</label>
                    <div class="table-container" id="sourcePreview">
                        <div class="empty-state" style="padding: 24px; text-align: center; color: var(--text-muted);">
                            <div class="empty-icon" style="font-size: 32px; margin-bottom: 8px;">ğŸ“Š</div>
                            <p>è¯·ä¸Šä¼  CSV æ–‡ä»¶æŸ¥çœ‹æ•°æ®</p>
                        </div>
                    </div>
                </div>

                <div class="status-bar" id="sourceStatus">
                    <span class="status-text">ç­‰å¾…ä¸Šä¼ æ–‡ä»¶...</span>
                </div>
            </div>

            <!-- å³ä¾§ï¼šè¾“å‡ºé…ç½® -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon">ğŸ“</span>
                        è¾“å‡ºé…ç½®
                    </div>
                    <button class="btn btn-primary btn-sm" onclick="showColumnModal()">+ æ·»åŠ åˆ—</button>
                </div>

                <div class="form-group">
                    <label>ç›®æ ‡åˆ—é…ç½®</label>
                    <div class="column-list" id="targetColumns">
                        <!-- Columns generated by JS -->
                    </div>
                </div>

                <div class="form-group" style="margin-top: 24px;">
                    <label>è½¬æ¢ç»“æœé¢„è§ˆ</label>
                    <div class="table-container" id="resultPreview">
                        <div class="empty-state" style="padding: 24px; text-align: center; color: var(--text-muted);">
                            <div class="empty-icon" style="font-size: 32px; margin-bottom: 8px;">ğŸ”„</div>
                            <p>é…ç½®æ˜ å°„è§„åˆ™åæŸ¥çœ‹ç»“æœ</p>
                        </div>
                    </div>
                </div>

                <div class="status-bar" id="resultStatus">
                    <span class="status-text">ç­‰å¾…è½¬æ¢...</span>
                </div>
            </div>
        </div>

        <!-- æ˜ å°„è§„åˆ™é…ç½® -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">
                    <span class="icon">ğŸ”—</span>
                    å­—æ®µæ˜ å°„è§„åˆ™
                </div>
            </div>

            <div class="mapping-list" id="mappingList">
                <div class="empty-state" style="padding: 24px; text-align: center; color: var(--text-muted);">
                    <p>è¯·å…ˆæ·»åŠ ç›®æ ‡åˆ—</p>
                </div>
            </div>
        </div>
        
        <!-- Sticky Action Bar -->
        <div class="action-bar">
            <div>
                <span class="status-text" id="convertStatus"></span>
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="previewResult()">ğŸ”„ åˆ·æ–°é¢„è§ˆ</button>
                <button class="btn btn-primary" onclick="checkRules()">ğŸ” è§„åˆ™è‡ªæ£€</button>
                <button class="btn btn-success" onclick="exportCSV()">ğŸ“¥ å¯¼å‡º CSV</button>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ åˆ—å¼¹çª— -->
    <div class="modal-overlay" id="columnModal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="modal-title">æ·»åŠ ç›®æ ‡åˆ—</h3>
                    <button class="modal-close" onclick="closeColumnModal()">Ã—</button>
                </div>
            </div>
            <div class="form-group">
                <label>åˆ—å</label>
                <input type="text" id="newColumnName" placeholder="è¯·è¾“å…¥åˆ—å">
            </div>
            <div class="form-group">
                <label>é»˜è®¤å€¼ï¼ˆå¯é€‰ï¼‰</label>
                <input type="text" id="newColumnDefault" placeholder="ç•™ç©ºåˆ™æ— é»˜è®¤å€¼">
            </div>
            <div class="btn-group" style="margin-top: auto; width: 100%;">
                <button class="btn btn-secondary" style="flex: 1;" onclick="closeColumnModal()">å–æ¶ˆ</button>
                <button class="btn btn-primary" style="flex: 1;" onclick="addColumn()">æ·»åŠ </button>
            </div>
        </div>
    </div>

    <!-- éšè—çš„å¯¼å…¥æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="configImportInput" accept=".json" style="display: none;">

    <!-- è§„åˆ™è‡ªæ£€å¼¹çª— -->
    <div class="modal-overlay" id="ruleCheckModal">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="modal-title">ğŸ” è§„åˆ™è‡ªæ£€ç»“æœ</h3>
                    <button class="modal-close" onclick="closeRuleCheckModal()">Ã—</button>
                </div>
            </div>
            <div id="ruleCheckSummary" class="rule-check-summary"></div>
            <div id="ruleCheckContent" style="flex: 1; overflow-y: auto;"></div>
            <div class="btn-group" style="margin-top: 20px; width: 100%;">
                <button class="btn btn-secondary" style="width: 100%;" onclick="closeRuleCheckModal()">å…³é—­</button>
            </div>
        </div>
    </div>

    <script>
        // ============== å…¨å±€çŠ¶æ€ ==============
        let sourceData = [];
        let sourceHeaders = [];
        let rawFileContent = '';
        let targetColumns = [
            { name: 'äº¤æ˜“æ—¥æœŸ', defaultValue: '' },
            { name: 'æ”¶æ”¯ç±»å‹', defaultValue: '' },
            { name: 'æ”¶æ”¯é¡¹ç›®', defaultValue: '' },
            { name: 'é‡‘é¢', defaultValue: '' },
            { name: 'è´¦æˆ·åç§°', defaultValue: '' },
            { name: 'æ ‡ç­¾', defaultValue: '' },
            { name: 'å¤‡æ³¨', defaultValue: '' }
        ];
        let mappingRules = {};

        // ============== é¢„è®¾é…ç½®ï¼ˆä» JSON æ ‡ç­¾åŠ è½½ï¼‰ ==============
        let presets = {};
        try {
            const presetScript = document.getElementById('preset-config');
            if (presetScript) {
                presets = JSON.parse(presetScript.textContent);
            }
        } catch (e) {
            console.error('åŠ è½½é¢„è®¾é…ç½®å¤±è´¥:', e);
        }

        // ============== æ–‡ä»¶ä¸Šä¼ å¤„ç† ==============
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');

        // Check if mobile for explicit button
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            uploadZone.style.display = 'none';
            document.getElementById('mobileUploadBtn').style.display = 'block';
        } else {
            uploadZone.classList.remove('hidden');
        }

        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.name.endsWith('.csv')) {
                showToast('è¯·ä¸Šä¼  CSV æ ¼å¼æ–‡ä»¶', 'error');
                return;
            }

            const encoding = document.getElementById('fileEncoding').value;
            const reader = new FileReader();
            
            reader.onload = (e) => {
                rawFileContent = e.target.result;
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = formatFileSize(file.size);
                document.getElementById('fileInfo').classList.remove('hidden');
                document.getElementById('fileInfo').style.display = 'flex'; // Ensure flex
                uploadZone.classList.add('hidden');
                document.getElementById('mobileUploadBtn').style.display = 'none';
                // è‡ªåŠ¨æ£€æµ‹è¡¨å¤´è¡Œ
                autoDetectHeader();
            };

            if (encoding === 'UTF-8') {
                reader.readAsText(file, 'UTF-8');
            } else {
                reader.readAsText(file, encoding);
            }
        }

        function clearFile() {
            rawFileContent = '';
            sourceData = [];
            sourceHeaders = [];
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInfo').style.display = 'none';
            
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                document.getElementById('mobileUploadBtn').style.display = 'block';
            } else {
                uploadZone.classList.remove('hidden');
            }
            
            document.getElementById('sourcePreview').innerHTML = `
                <div class="empty-state" style="padding: 24px; text-align: center; color: var(--text-muted);">
                    <div class="empty-icon" style="font-size: 32px; margin-bottom: 8px;">ğŸ“Š</div>
                    <p>è¯·ä¸Šä¼  CSV æ–‡ä»¶æŸ¥çœ‹æ•°æ®</p>
                </div>
            `;
            document.getElementById('sourceStatus').innerHTML = '<span class="status-text">ç­‰å¾…ä¸Šä¼ æ–‡ä»¶...</span>';
            renderMappingList();
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ============== CSV è§£æ ==============
        function parseCSV(text) {
            const lines = [];
            let currentLine = '';
            let inQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (char === '"') {
                    if (inQuotes && text[i + 1] === '"') {
                        currentLine += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (currentLine.trim()) {
                        lines.push(currentLine);
                    }
                    currentLine = '';
                    if (char === '\r' && text[i + 1] === '\n') {
                        i++;
                    }
                } else {
                    currentLine += char;
                }
            }
            
            if (currentLine.trim()) {
                lines.push(currentLine);
            }
            
            return lines.map(line => {
                const cells = [];
                let currentCell = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        if (inQuotes && line[i + 1] === '"') {
                            currentCell += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        cells.push(currentCell.trim());
                        currentCell = '';
                    } else {
                        currentCell += char;
                    }
                }
                
                cells.push(currentCell.trim());
                return cells;
            });
        }

        function parseSourceData() {
            if (!rawFileContent) return;

            const skipRows = parseInt(document.getElementById('skipRows').value) || 0;
            const allRows = parseCSV(rawFileContent);
            
            if (allRows.length <= skipRows) {
                showToast('è·³è¿‡è¡Œæ•°è¿‡å¤šï¼Œæ²¡æœ‰æ•°æ®å¯è§£æ', 'error');
                return;
            }

            sourceHeaders = allRows[skipRows] || [];
            sourceData = allRows.slice(skipRows + 1).filter(row => row.some(cell => cell.trim()));

            renderSourcePreview();
            renderMappingList();
            
            document.getElementById('sourceStatus').innerHTML = `
                <span class="status-text">å…± <span class="status-count">${sourceData.length}</span> æ¡è®°å½•ï¼Œ${sourceHeaders.length} åˆ—</span>
            `;
        }

        function autoDetectHeader() {
            if (!rawFileContent) {
                showToast('è¯·å…ˆä¸Šä¼ æ–‡ä»¶', 'error');
                return;
            }

            const allRows = parseCSV(rawFileContent);
            if (allRows.length === 0) {
                showToast('æ–‡ä»¶å†…å®¹ä¸ºç©º', 'error');
                return;
            }

            // å¸¸è§çš„è¡¨å¤´å…³é”®è¯
            const headerKeywords = [
                'æ—¥æœŸ', 'æ—¶é—´', 'é‡‘é¢', 'ç±»å‹', 'è´¦æˆ·', 'å¤‡æ³¨', 'æ ‡ç­¾', 'æ”¶æ”¯', 'æ”¯ä»˜',
                'äº¤æ˜“', 'è®¢å•', 'å•†å®¶', 'åˆ†ç±»', 'é¡¹ç›®', 'åç§°', 'ç¼–å·', 'å•å·',
                'date', 'time', 'amount', 'type', 'account', 'note', 'category'
            ];

            let bestRowIndex = 0;
            let bestScore = -1;

            // åˆ†æå‰50è¡Œï¼Œæ‰¾åˆ°æœ€å¯èƒ½æ˜¯è¡¨å¤´çš„è¡Œ
            const maxScan = Math.min(allRows.length, 50);
            
            for (let i = 0; i < maxScan; i++) {
                const row = allRows[i];
                if (!row || row.length === 0) continue;

                let score = 0;
                
                // 1. åˆ—æ•°è¾ƒå¤šçš„è¡Œå¾—åˆ†æ›´é«˜ï¼ˆä½†ä¸èƒ½æ˜¯ç©ºåˆ—å¤ªå¤šï¼‰
                const nonEmptyCols = row.filter(cell => cell && cell.trim()).length;
                if (nonEmptyCols >= 3) {
                    score += nonEmptyCols * 2;
                }

                // 2. åŒ…å«è¡¨å¤´å…³é”®è¯çš„å¾—åˆ†æ›´é«˜
                const rowText = row.join(' ').toLowerCase();
                headerKeywords.forEach(keyword => {
                    if (rowText.includes(keyword.toLowerCase())) {
                        score += 10;
                    }
                });

                // 3. æ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦çœ‹èµ·æ¥åƒæ•°æ®è¡Œï¼ˆåŒ…å«æ•°å­—æˆ–æ—¥æœŸæ ¼å¼ï¼‰
                if (i + 1 < allRows.length) {
                    const nextRow = allRows[i + 1];
                    if (nextRow && nextRow.length > 0) {
                        const nextRowText = nextRow.join(' ');
                        // å¦‚æœä¸‹ä¸€è¡ŒåŒ…å«æ—¥æœŸæ ¼å¼æˆ–æ•°å­—ï¼Œè¯´æ˜å½“å‰è¡Œå¯èƒ½æ˜¯è¡¨å¤´
                        if (/\d{4}[-\/]\d{1,2}[-\/]\d{1,2}/.test(nextRowText)) {
                            score += 15; // æ—¥æœŸæ ¼å¼
                        }
                        if (/Â¥?\d+\.?\d*/.test(nextRowText)) {
                            score += 5; // æ•°å­—/é‡‘é¢æ ¼å¼
                        }
                    }
                }

                // 4. å¦‚æœå½“å‰è¡Œæœ¬èº«åŒ…å«å¤ªå¤šæ•°å­—ï¼Œå¯èƒ½æ˜¯æ•°æ®è¡Œè€Œéè¡¨å¤´
                const numbersInRow = (row.join(' ').match(/\d+\.?\d*/g) || []).length;
                if (numbersInRow > row.length) {
                    score -= 10;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestRowIndex = i;
                }
            }

            // æ›´æ–°è·³è¿‡è¡Œæ•°å¹¶é‡æ–°è§£æ
            document.getElementById('skipRows').value = bestRowIndex;
            parseSourceData();
            
            showToast(`å·²è‡ªåŠ¨æ£€æµ‹åˆ°è¡¨å¤´åœ¨ç¬¬ ${bestRowIndex + 1} è¡Œï¼ˆè·³è¿‡ ${bestRowIndex} è¡Œï¼‰`, 'success');
        }

        function renderSourcePreview() {
            if (sourceHeaders.length === 0) return;

            const previewData = sourceData.slice(0, 10);
            let html = '<table><thead><tr>';
            
            sourceHeaders.forEach(header => {
                html += `<th>${escapeHtml(header)}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            previewData.forEach(row => {
                html += '<tr>';
                sourceHeaders.forEach((_, i) => {
                    html += `<td>${escapeHtml(row[i] || '')}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (sourceData.length > 10) {
                html += `<div class="scroll-hint">æ˜¾ç¤ºå‰ 10 æ¡ï¼Œå…± ${sourceData.length} æ¡</div>`;
            }
            
            document.getElementById('sourcePreview').innerHTML = html;
        }

        // ============== ç›®æ ‡åˆ—ç®¡ç† ==============
        function renderTargetColumns() {
            const container = document.getElementById('targetColumns');
            let html = '';
            
            targetColumns.forEach((col, index) => {
                html += `
                    <div class="column-item">
                        <span class="drag-handle">â‹®â‹®</span>
                        <input type="text" value="${escapeHtml(col.name)}" 
                            onchange="updateColumnName(${index}, this.value)" 
                            placeholder="åˆ—å">
                        <input type="text" value="${escapeHtml(col.defaultValue)}" 
                            onchange="updateColumnDefault(${index}, this.value)" 
                            placeholder="é»˜è®¤å€¼" style="max-width: 120px;">
                        <button class="btn btn-danger btn-sm" onclick="removeColumn(${index})">åˆ é™¤</button>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<div class="empty-state"><p>æš‚æ— ç›®æ ‡åˆ—</p></div>';
        }

        function updateColumnName(index, name) {
            const oldName = targetColumns[index].name;
            targetColumns[index].name = name;
            
            // æ›´æ–°æ˜ å°„è§„åˆ™ä¸­çš„é”®å
            if (mappingRules[oldName]) {
                mappingRules[name] = mappingRules[oldName];
                delete mappingRules[oldName];
            }
            
            renderMappingList();
        }

        function updateColumnDefault(index, value) {
            targetColumns[index].defaultValue = value;
        }

        function removeColumn(index) {
            const name = targetColumns[index].name;
            delete mappingRules[name];
            targetColumns.splice(index, 1);
            renderTargetColumns();
            renderMappingList();
        }

        function showColumnModal() {
            document.getElementById('columnModal').classList.add('active');
            document.getElementById('newColumnName').value = '';
            document.getElementById('newColumnDefault').value = '';
            document.getElementById('newColumnName').focus();
        }

        function closeColumnModal() {
            document.getElementById('columnModal').classList.remove('active');
        }

        function addColumn() {
            const name = document.getElementById('newColumnName').value.trim();
            const defaultValue = document.getElementById('newColumnDefault').value;
            
            if (!name) {
                showToast('è¯·è¾“å…¥åˆ—å', 'error');
                return;
            }
            
            if (targetColumns.some(col => col.name === name)) {
                showToast('åˆ—åå·²å­˜åœ¨', 'error');
                return;
            }
            
            targetColumns.push({ name, defaultValue });
            renderTargetColumns();
            renderMappingList();
            closeColumnModal();
            showToast('åˆ—æ·»åŠ æˆåŠŸ', 'success');
        }

        // ============== æ˜ å°„è§„åˆ™ç®¡ç† ==============
        function renderMappingList() {
            const container = document.getElementById('mappingList');
            let html = '';
            
            targetColumns.forEach(col => {
                const rule = mappingRules[col.name] || { type: 'fixed', fixedValue: col.defaultValue };
                
                html += `
                    <div class="mapping-item">
                        <div class="mapping-header">
                            <span class="mapping-target">${escapeHtml(col.name)}</span>
                            <span class="tag ${getRuleTypeTag(rule.type)}">${getRuleTypeName(rule.type)}</span>
                        </div>
                        <div class="mapping-body">
                            <div class="form-group">
                                <label>è½¬æ¢ç±»å‹</label>
                                <select onchange="updateRuleType('${escapeHtml(col.name)}', this.value)">
                                    <option value="direct" ${rule.type === 'direct' ? 'selected' : ''}>ç›´æ¥æ˜ å°„</option>
                                    <option value="date" ${rule.type === 'date' ? 'selected' : ''}>æ—¥æœŸæ ¼å¼è½¬æ¢</option>
                                    <option value="amount" ${rule.type === 'amount' ? 'selected' : ''}>é‡‘é¢å¤„ç†</option>
                                    <option value="valueMap" ${rule.type === 'valueMap' ? 'selected' : ''}>å€¼æ˜ å°„</option>
                                    <option value="fuzzyMap" ${rule.type === 'fuzzyMap' ? 'selected' : ''}>æ¨¡ç³ŠåŒ¹é…æ˜ å°„</option>
                                    <option value="combinedCondition" ${rule.type === 'combinedCondition' ? 'selected' : ''}>ç»„åˆæ¡ä»¶æ˜ å°„</option>
                                    <option value="fixed" ${rule.type === 'fixed' ? 'selected' : ''}>å›ºå®šå€¼</option>
                                    <option value="expression" ${rule.type === 'expression' ? 'selected' : ''}>è‡ªå®šä¹‰è¡¨è¾¾å¼</option>
                                </select>
                            </div>
                            ${renderRuleConfig(col.name, rule)}
                        </div>
                        ${renderRuleExtra(col.name, rule)}
                    </div>
                `;
            });
            
            container.innerHTML = html || '<div class="empty-state"><p>è¯·å…ˆæ·»åŠ ç›®æ ‡åˆ—</p></div>';
        }

        function renderRuleConfig(colName, rule) {
            const sourceOptions = sourceHeaders.map(h => 
                `<option value="${escapeHtml(h)}" ${rule.sourceColumn === h ? 'selected' : ''}>${escapeHtml(h)}</option>`
            ).join('');
            
            switch (rule.type) {
                case 'direct':
                case 'date':
                case 'amount':
                case 'valueMap':
                case 'fuzzyMap':
                    return `
                        <div class="form-group">
                            <label>æºåˆ—</label>
                            <select onchange="updateRuleSourceColumn('${escapeHtml(colName)}', this.value)">
                                <option value="">-- é€‰æ‹©æºåˆ— --</option>
                                ${sourceOptions}
                            </select>
                        </div>
                    `;
                case 'fixed':
                    return `
                        <div class="form-group">
                            <label>å›ºå®šå€¼</label>
                            <input type="text" value="${escapeHtml(rule.fixedValue || '')}" 
                                onchange="updateRuleFixedValue('${escapeHtml(colName)}', this.value)"
                                placeholder="è¾“å…¥å›ºå®šå€¼">
                        </div>
                    `;
                case 'expression':
                    return `
                        <div class="form-group" style="grid-column: 1 / -1;">
                            <label>JavaScript è¡¨è¾¾å¼ (ä½¿ç”¨ row.åˆ—å è®¿é—®æ•°æ®)</label>
                            <textarea onchange="updateRuleExpression('${escapeHtml(colName)}', this.value)"
                                placeholder="ä¾‹å¦‚ï¼šrow['é‡‘é¢'].replace('Â¥', '')">${escapeHtml(rule.expression || '')}</textarea>
                        </div>
                    `;
                case 'combinedCondition':
                    return `
                        <div class="form-group" style="grid-column: 1 / -1;">
                            <label>é»˜è®¤å€¼ï¼ˆæ— è§„åˆ™åŒ¹é…æ—¶ï¼‰</label>
                            <input type="text" value="${escapeHtml(rule.defaultValue || '')}"
                                onchange="updateCombinedDefault('${escapeHtml(colName)}', this.value)"
                                placeholder="æœªåŒ¹é…ä»»ä½•è§„åˆ™æ—¶çš„å€¼">
                        </div>
                    `;
                default:
                    return '';
            }
        }

        function renderRuleExtra(colName, rule) {
            if (rule.type === 'date') {
                return `
                    <div class="mapping-extra">
                        <div class="form-group">
                            <label>æ—¥æœŸæ ¼å¼ï¼ˆè¾“å‡ºï¼‰</label>
                            <select onchange="updateRuleDateFormat('${escapeHtml(colName)}', this.value)">
                                <option value="YYYY-MM-DD" ${rule.dateFormat === 'YYYY-MM-DD' ? 'selected' : ''}>YYYY-MM-DD</option>
                                <option value="YYYY/MM/DD" ${rule.dateFormat === 'YYYY/MM/DD' ? 'selected' : ''}>YYYY/MM/DD</option>
                                <option value="MM-DD-YYYY" ${rule.dateFormat === 'MM-DD-YYYY' ? 'selected' : ''}>MM-DD-YYYY</option>
                            </select>
                        </div>
                    </div>
                `;
            }
            
            if (rule.type === 'valueMap') {
                const mappings = rule.valueMappings || [];
                let mappingsHtml = mappings.map((m, i) => `
                    <div class="value-mapping-item">
                        <input type="text" value="${escapeHtml(m.from)}" 
                            onchange="updateValueMapping('${escapeHtml(colName)}', ${i}, 'from', this.value)"
                            placeholder="åŸå€¼">
                        <span class="arrow-icon">â†’</span>
                        <input type="text" value="${escapeHtml(m.to)}" 
                            onchange="updateValueMapping('${escapeHtml(colName)}', ${i}, 'to', this.value)"
                            placeholder="æ˜ å°„å€¼">
                        <button class="btn btn-danger btn-sm" onclick="removeValueMapping('${escapeHtml(colName)}', ${i})">åˆ é™¤</button>
                    </div>
                `).join('');
                
                return `
                    <div class="mapping-extra">
                        <label>å€¼æ˜ å°„è§„åˆ™ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰</label>
                        <div class="value-mapping-list">
                            ${mappingsHtml}
                        </div>
                        <button class="btn btn-secondary btn-sm" style="margin-top: 8px;" 
                            onclick="addValueMapping('${escapeHtml(colName)}')">+ æ·»åŠ æ˜ å°„</button>
                    </div>
                `;
            }
            
            if (rule.type === 'fuzzyMap') {
                const mappings = rule.fuzzyMappings || [];
                let mappingsHtml = mappings.map((m, i) => `
                    <div class="fuzzy-mapping-item">
                        <input type="text" value="${escapeHtml(m.contains)}" 
                            onchange="updateFuzzyMapping('${escapeHtml(colName)}', ${i}, 'contains', this.value)"
                            placeholder="åŒ…å«å­—ç¬¦ä¸²">
                        <span class="arrow-icon">â†’</span>
                        <input type="text" value="${escapeHtml(m.mapTo)}" 
                            onchange="updateFuzzyMapping('${escapeHtml(colName)}', ${i}, 'mapTo', this.value)"
                            placeholder="æ˜ å°„å€¼">
                        <button class="btn btn-danger btn-sm" onclick="removeFuzzyMapping('${escapeHtml(colName)}', ${i})">åˆ é™¤</button>
                    </div>
                `).join('');
                
                return `
                    <div class="mapping-extra">
                        <label>æ¨¡ç³ŠåŒ¹é…è§„åˆ™ï¼ˆåŒ…å«å³åŒ¹é…ï¼ŒæŒ‰é¡ºåºä¼˜å…ˆï¼‰</label>
                        <div class="fuzzy-mapping-list">
                            ${mappingsHtml}
                        </div>
                        <button class="btn btn-secondary btn-sm" style="margin-top: 8px;" 
                            onclick="addFuzzyMapping('${escapeHtml(colName)}')">+ æ·»åŠ è§„åˆ™</button>
                        <div class="form-group" style="margin-top: 12px;">
                            <label>é»˜è®¤å€¼ï¼ˆæ— åŒ¹é…æ—¶ï¼‰</label>
                            <input type="text" value="${escapeHtml(rule.defaultValue || '')}"
                                onchange="updateFuzzyDefault('${escapeHtml(colName)}', this.value)"
                                placeholder="æœªåŒ¹é…æ—¶çš„é»˜è®¤å€¼">
                        </div>
                    </div>
                `;
            }
            
            if (rule.type === 'combinedCondition') {
                const rules = rule.combinedConditions || [];
                const sourceOptions = sourceHeaders.map(h => 
                    `<option value="${escapeHtml(h)}">${escapeHtml(h)}</option>`
                ).join('');
                
                let rulesHtml = rules.map((r, ruleIndex) => {
                    const conditionsHtml = (r.conditions || []).map((cond, condIndex) => `
                        <div class="condition-item">
                            <select onchange="updateCombinedConditionType('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, this.value)">
                                <option value="timeRange" ${cond.type === 'timeRange' ? 'selected' : ''}>æ—¶é—´èŒƒå›´</option>
                                <option value="contains" ${cond.type === 'contains' ? 'selected' : ''}>åŒ…å«ä»»ä¸€(OR)</option>
                                <option value="containsAll" ${cond.type === 'containsAll' ? 'selected' : ''}>åŒ…å«å…¨éƒ¨(AND)</option>
                                <option value="equals" ${cond.type === 'equals' ? 'selected' : ''}>ç²¾ç¡®åŒ¹é…</option>
                                <option value="startsWith" ${cond.type === 'startsWith' ? 'selected' : ''}>å¼€å¤´åŒ¹é…</option>
                                <option value="regex" ${cond.type === 'regex' ? 'selected' : ''}>æ­£åˆ™åŒ¹é…</option>
                            </select>
                            ${renderConditionInputs(colName, ruleIndex, condIndex, cond, sourceOptions)}
                            <button class="btn btn-danger btn-sm" onclick="removeCombinedCondition('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex})">Ã—</button>
                        </div>
                    `).join('');
                    
                    return `
                        <div class="combined-rule-item">
                            <div class="combined-rule-header">
                                <span class="rule-title">è§„åˆ™ ${ruleIndex + 1}</span>
                                <button class="btn btn-danger btn-sm" onclick="removeCombinedRule('${escapeHtml(colName)}', ${ruleIndex})">åˆ é™¤è§„åˆ™</button>
                            </div>
                            <label style="font-size: 0.85rem; color: var(--text-muted);">æ¡ä»¶ï¼ˆå…¨éƒ¨æ»¡è¶³æ—¶åŒ¹é…ï¼‰</label>
                            <div class="condition-list">
                                ${conditionsHtml || '<div style="color: var(--text-muted); padding: 12px;">æš‚æ— æ¡ä»¶</div>'}
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="addCombinedCondition('${escapeHtml(colName)}', ${ruleIndex})">+ æ·»åŠ æ¡ä»¶</button>
                            <div class="combined-result">
                                <span style="color: var(--text-secondary);">åŒ¹é…åæ˜ å°„ä¸ºï¼š</span>
                                <input type="text" value="${escapeHtml(r.targetValue || '')}"
                                    onchange="updateCombinedTargetValue('${escapeHtml(colName)}', ${ruleIndex}, this.value)"
                                    placeholder="æ˜ å°„å€¼">
                            </div>
                        </div>
                    `;
                }).join('');
                
                return `
                    <div class="mapping-extra">
                        <label>ç»„åˆæ¡ä»¶è§„åˆ™ï¼ˆæŒ‰é¡ºåºåŒ¹é…ï¼Œæ»¡è¶³æ‰€æœ‰æ¡ä»¶æ—¶æ˜ å°„ï¼‰</label>
                        <div class="combined-rule-list">
                            ${rulesHtml || '<div style="color: var(--text-muted); padding: 12px;">æš‚æ— è§„åˆ™ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ </div>'}
                        </div>
                        <button class="btn btn-primary btn-sm" style="margin-top: 8px;" 
                            onclick="addCombinedRule('${escapeHtml(colName)}')">+ æ·»åŠ ç»„åˆè§„åˆ™</button>
                    </div>
                `;
            }
            
            return '';
        }
        
        function renderConditionInputs(colName, ruleIndex, condIndex, cond, sourceOptions) {
            switch (cond.type) {
                case 'timeRange':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©æ—¶é—´åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="time" value="${cond.startTime || '11:00'}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'startTime', this.value)"
                            style="width: 100px;">
                        <span style="color: var(--text-muted);">è‡³</span>
                        <input type="time" value="${cond.endTime || '14:00'}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'endTime', this.value)"
                            style="width: 100px;">
                    `;
                case 'contains':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="text" value="${escapeHtml(cond.value || '')}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'value', this.value)"
                            placeholder="å…³é”®è¯ï¼Œé€—å·åˆ†éš”ï¼ŒåŒ¹é…ä»»ä¸€" style="min-width: 200px;"
                            title="å¤šå…³é”®è¯ç”¨é€—å·åˆ†éš”ï¼ŒåŒ¹é…ä»»ä¸€å³å¯ï¼ˆORå…³ç³»ï¼‰">
                    `;
                case 'containsAll':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="text" value="${escapeHtml(cond.value || '')}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'value', this.value)"
                            placeholder="å…³é”®è¯ï¼Œé€—å·åˆ†éš”ï¼Œéœ€å…¨éƒ¨åŒ…å«" style="min-width: 200px;"
                            title="å¤šå…³é”®è¯ç”¨é€—å·åˆ†éš”ï¼Œéœ€è¦å…¨éƒ¨åŒ¹é…ï¼ˆANDå…³ç³»ï¼‰">
                    `;
                case 'startsWith':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="text" value="${escapeHtml(cond.value || '')}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'value', this.value)"
                            placeholder="å¼€å¤´æ–‡æœ¬">
                    `;
                case 'equals':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="text" value="${escapeHtml(cond.value || '')}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'value', this.value)"
                            placeholder="ç²¾ç¡®åŒ¹é…å€¼">
                    `;
                case 'regex':
                    return `
                        <select onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'sourceColumn', this.value)">
                            <option value="">é€‰æ‹©åˆ—</option>
                            ${sourceOptions.replace(`value="${escapeHtml(cond.sourceColumn)}"`, `value="${escapeHtml(cond.sourceColumn)}" selected`)}
                        </select>
                        <input type="text" value="${escapeHtml(cond.value || '')}"
                            onchange="updateCombinedConditionField('${escapeHtml(colName)}', ${ruleIndex}, ${condIndex}, 'value', this.value)"
                            placeholder="æ­£åˆ™è¡¨è¾¾å¼" style="min-width: 180px;"
                            title="JavaScriptæ­£åˆ™è¡¨è¾¾å¼ï¼Œå¦‚ï¼šè€ä¹¡é¸¡|æ°´é¥º|é¢æ¡">
                    `;
                default:
                    return '';
            }
        }

        function getRuleTypeName(type) {
            const names = {
                'direct': 'ç›´æ¥æ˜ å°„',
                'date': 'æ—¥æœŸè½¬æ¢',
                'amount': 'é‡‘é¢å¤„ç†',
                'valueMap': 'å€¼æ˜ å°„',
                'fuzzyMap': 'æ¨¡ç³ŠåŒ¹é…',
                'combinedCondition': 'ç»„åˆæ¡ä»¶',
                'fixed': 'å›ºå®šå€¼',
                'expression': 'è¡¨è¾¾å¼'
            };
            return names[type] || type;
        }

        function getRuleTypeTag(type) {
            const tags = {
                'direct': 'tag-blue',
                'date': 'tag-green',
                'amount': 'tag-orange',
                'valueMap': 'tag-blue',
                'fuzzyMap': 'tag-green',
                'combinedCondition': 'tag-purple',
                'fixed': '',
                'expression': 'tag-orange'
            };
            return tags[type] || '';
        }

        function updateRuleType(colName, type) {
            mappingRules[colName] = mappingRules[colName] || {};
            mappingRules[colName].type = type;
            
            if (type === 'valueMap' && !mappingRules[colName].valueMappings) {
                mappingRules[colName].valueMappings = [];
            }
            if (type === 'fuzzyMap' && !mappingRules[colName].fuzzyMappings) {
                mappingRules[colName].fuzzyMappings = [];
            }
            if (type === 'combinedCondition' && !mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions = [];
            }
            if (type === 'date' && !mappingRules[colName].dateFormat) {
                mappingRules[colName].dateFormat = 'YYYY-MM-DD';
            }
            
            renderMappingList();
        }

        function updateRuleSourceColumn(colName, value) {
            mappingRules[colName] = mappingRules[colName] || {};
            mappingRules[colName].sourceColumn = value;
        }

        function updateRuleFixedValue(colName, value) {
            mappingRules[colName] = mappingRules[colName] || { type: 'fixed' };
            mappingRules[colName].fixedValue = value;
        }

        function updateRuleExpression(colName, value) {
            mappingRules[colName] = mappingRules[colName] || { type: 'expression' };
            mappingRules[colName].expression = value;
        }

        function updateRuleDateFormat(colName, value) {
            mappingRules[colName] = mappingRules[colName] || { type: 'date' };
            mappingRules[colName].dateFormat = value;
        }

        // å€¼æ˜ å°„
        function addValueMapping(colName) {
            mappingRules[colName] = mappingRules[colName] || { type: 'valueMap', valueMappings: [] };
            mappingRules[colName].valueMappings = mappingRules[colName].valueMappings || [];
            mappingRules[colName].valueMappings.push({ from: '', to: '' });
            renderMappingList();
        }

        function updateValueMapping(colName, index, field, value) {
            if (mappingRules[colName] && mappingRules[colName].valueMappings) {
                mappingRules[colName].valueMappings[index][field] = value;
            }
        }

        function removeValueMapping(colName, index) {
            if (mappingRules[colName] && mappingRules[colName].valueMappings) {
                mappingRules[colName].valueMappings.splice(index, 1);
                renderMappingList();
            }
        }

        // æ¨¡ç³ŠåŒ¹é…æ˜ å°„
        function addFuzzyMapping(colName) {
            mappingRules[colName] = mappingRules[colName] || { type: 'fuzzyMap', fuzzyMappings: [] };
            mappingRules[colName].fuzzyMappings = mappingRules[colName].fuzzyMappings || [];
            mappingRules[colName].fuzzyMappings.push({ contains: '', mapTo: '' });
            renderMappingList();
        }

        function updateFuzzyMapping(colName, index, field, value) {
            if (mappingRules[colName] && mappingRules[colName].fuzzyMappings) {
                mappingRules[colName].fuzzyMappings[index][field] = value;
            }
        }

        function removeFuzzyMapping(colName, index) {
            if (mappingRules[colName] && mappingRules[colName].fuzzyMappings) {
                mappingRules[colName].fuzzyMappings.splice(index, 1);
                renderMappingList();
            }
        }

        function updateFuzzyDefault(colName, value) {
            mappingRules[colName] = mappingRules[colName] || { type: 'fuzzyMap' };
            mappingRules[colName].defaultValue = value;
        }

        // ç»„åˆæ¡ä»¶æ˜ å°„
        function updateCombinedDefault(colName, value) {
            mappingRules[colName] = mappingRules[colName] || { type: 'combinedCondition' };
            mappingRules[colName].defaultValue = value;
        }

        function addCombinedRule(colName) {
            mappingRules[colName] = mappingRules[colName] || { type: 'combinedCondition', combinedConditions: [] };
            mappingRules[colName].combinedConditions = mappingRules[colName].combinedConditions || [];
            mappingRules[colName].combinedConditions.push({
                conditions: [],
                mapTo: ''
            });
            renderMappingList();
        }

        function removeCombinedRule(colName, ruleIndex) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions.splice(ruleIndex, 1);
                renderMappingList();
            }
        }

        function updateCombinedTargetValue(colName, ruleIndex, value) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions[ruleIndex].targetValue = value;
            }
        }

        function addCombinedCondition(colName, ruleIndex) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions[ruleIndex].conditions = 
                    mappingRules[colName].combinedConditions[ruleIndex].conditions || [];
                mappingRules[colName].combinedConditions[ruleIndex].conditions.push({
                    type: 'contains',
                    sourceColumn: '',
                    value: ''
                });
                renderMappingList();
            }
        }

        function removeCombinedCondition(colName, ruleIndex, condIndex) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions[ruleIndex].conditions.splice(condIndex, 1);
                renderMappingList();
            }
        }

        function updateCombinedConditionType(colName, ruleIndex, condIndex, type) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                const cond = mappingRules[colName].combinedConditions[ruleIndex].conditions[condIndex];
                cond.type = type;
                // åˆå§‹åŒ–æ—¶é—´èŒƒå›´é»˜è®¤å€¼
                if (type === 'timeRange') {
                    cond.startTime = cond.startTime || '11:00';
                    cond.endTime = cond.endTime || '14:00';
                }
                renderMappingList();
            }
        }

        function updateCombinedConditionField(colName, ruleIndex, condIndex, field, value) {
            if (mappingRules[colName] && mappingRules[colName].combinedConditions) {
                mappingRules[colName].combinedConditions[ruleIndex].conditions[condIndex][field] = value;
            }
        }

        // ============== æ•°æ®è½¬æ¢ ==============
        function transformData() {
            if (sourceData.length === 0) return [];
            
            return sourceData.map((row, rowIndex) => {
                const rowObj = {};
                sourceHeaders.forEach((header, i) => {
                    rowObj[header] = row[i] || '';
                });
                
                const result = {};
                targetColumns.forEach(col => {
                    result[col.name] = applyRule(rowObj, col.name, col.defaultValue);
                });
                
                return result;
            });
        }

        function applyRule(row, colName, defaultValue) {
            const rule = mappingRules[colName];
            
            if (!rule) {
                return defaultValue || '';
            }
            
            try {
                switch (rule.type) {
                    case 'direct':
                        return rule.sourceColumn ? (row[rule.sourceColumn] || '') : defaultValue;
                    
                    case 'date':
                        if (!rule.sourceColumn) return defaultValue;
                        const dateStr = row[rule.sourceColumn] || '';
                        return formatDate(dateStr, rule.dateFormat);
                    
                    case 'amount':
                        if (!rule.sourceColumn) return defaultValue;
                        const amountStr = row[rule.sourceColumn] || '';
                        return amountStr.replace(/[Â¥ï¿¥,]/g, '').trim();
                    
                    case 'valueMap':
                        if (!rule.sourceColumn) return defaultValue;
                        const sourceVal = row[rule.sourceColumn] || '';
                        const mapping = (rule.valueMappings || []).find(m => m.from === sourceVal);
                        return mapping ? mapping.to : sourceVal;
                    
                    case 'fuzzyMap':
                        if (!rule.sourceColumn) return rule.defaultValue || defaultValue;
                        const fuzzyVal = row[rule.sourceColumn] || '';
                        const fuzzyMatch = (rule.fuzzyMappings || []).find(m => 
                            m.contains && fuzzyVal.includes(m.contains)
                        );
                        return fuzzyMatch ? fuzzyMatch.mapTo : (rule.defaultValue || defaultValue);
                    
                    case 'combinedCondition':
                        const combinedConditions = rule.combinedConditions || [];
                        for (const combinedRule of combinedConditions) {
                            const conditions = combinedRule.conditions || [];
                            if (conditions.length === 0) continue;
                            
                            const allMatch = conditions.every(cond => {
                                const sourceVal = row[cond.sourceColumn] || '';
                                
                                switch (cond.type) {
                                    case 'timeRange':
                                        // ä»æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²ä¸­æå–æ—¶é—´
                                        const timeMatch = sourceVal.match(/(\d{1,2}):(\d{2})/);
                                        if (!timeMatch) return false;
                                        const hour = parseInt(timeMatch[1]);
                                        const minute = parseInt(timeMatch[2]);
                                        const timeMinutes = hour * 60 + minute;
                                        
                                        const [startH, startM] = (cond.startTime || '00:00').split(':').map(Number);
                                        const [endH, endM] = (cond.endTime || '23:59').split(':').map(Number);
                                        const startMinutes = startH * 60 + startM;
                                        const endMinutes = endH * 60 + endM;
                                        
                                        return timeMinutes >= startMinutes && timeMinutes <= endMinutes;
                                    
                                    case 'contains':
                                        // æ”¯æŒå¤šå…³é”®è¯ï¼ˆé€—å·åˆ†éš”ï¼‰ï¼ŒåŒ¹é…ä»»ä¸€å³å¯ï¼ˆORå…³ç³»ï¼‰
                                        if (!cond.value) return false;
                                        const keywords = cond.value.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);
                                        return keywords.some(keyword => sourceVal.includes(keyword));
                                    
                                    case 'containsAll':
                                        // æ”¯æŒå¤šå…³é”®è¯ï¼ˆé€—å·åˆ†éš”ï¼‰ï¼Œéœ€å…¨éƒ¨åŒ¹é…ï¼ˆANDå…³ç³»ï¼‰
                                        if (!cond.value) return false;
                                        const allKeywords = cond.value.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);
                                        return allKeywords.every(keyword => sourceVal.includes(keyword));
                                    
                                    case 'equals':
                                        return sourceVal === cond.value;
                                    
                                    case 'startsWith':
                                        return cond.value && sourceVal.startsWith(cond.value);
                                    
                                    case 'regex':
                                        // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
                                        if (!cond.value) return false;
                                        try {
                                            const regex = new RegExp(cond.value, 'i');
                                            return regex.test(sourceVal);
                                        } catch (e) {
                                            return false;
                                        }
                                    
                                    default:
                                        return false;
                                }
                            });
                            
                            if (allMatch) {
                                return combinedRule.targetValue || '';
                            }
                        }
                        return rule.defaultValue || defaultValue;
                    
                    case 'fixed':
                        return rule.fixedValue !== undefined ? rule.fixedValue : defaultValue;
                    
                    case 'expression':
                        if (!rule.expression) return defaultValue;
                        const fn = new Function('row', `return ${rule.expression}`);
                        return fn(row) || '';
                    
                    default:
                        return defaultValue;
                }
            } catch (e) {
                console.error(`Error applying rule for ${colName}:`, e);
                return defaultValue;
            }
        }

        function formatDate(dateStr, format) {
            if (!dateStr) return '';
            
            // å°è¯•è§£æå„ç§æ—¥æœŸæ ¼å¼
            const match = dateStr.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
            if (!match) return dateStr;
            
            const [, year, month, day] = match;
            const mm = month.padStart(2, '0');
            const dd = day.padStart(2, '0');
            
            switch (format) {
                case 'YYYY-MM-DD':
                    return `${year}-${mm}-${dd}`;
                case 'YYYY/MM/DD':
                    return `${year}/${mm}/${dd}`;
                case 'MM-DD-YYYY':
                    return `${mm}-${dd}-${year}`;
                default:
                    return `${year}-${mm}-${dd}`;
            }
        }

        // ============== é¢„è§ˆå’Œå¯¼å‡º ==============
        function previewResult() {
            if (sourceData.length === 0) {
                showToast('è¯·å…ˆä¸Šä¼ æºæ•°æ®æ–‡ä»¶', 'error');
                return;
            }
            
            const result = transformData();
            const previewData = result.slice(0, 10);
            
            let html = '<table><thead><tr>';
            targetColumns.forEach(col => {
                html += `<th>${escapeHtml(col.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            previewData.forEach(row => {
                html += '<tr>';
                targetColumns.forEach(col => {
                    html += `<td>${escapeHtml(row[col.name] || '')}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (result.length > 10) {
                html += `<div class="scroll-hint">æ˜¾ç¤ºå‰ 10 æ¡ï¼Œå…± ${result.length} æ¡</div>`;
            }
            
            document.getElementById('resultPreview').innerHTML = html;
            document.getElementById('resultStatus').innerHTML = `
                <span class="status-text">å·²è½¬æ¢ <span class="status-count">${result.length}</span> æ¡è®°å½•</span>
            `;
            document.getElementById('convertStatus').textContent = `âœ… é¢„è§ˆå·²æ›´æ–°`;
        }

        function exportCSV() {
            if (sourceData.length === 0) {
                showToast('è¯·å…ˆä¸Šä¼ æºæ•°æ®æ–‡ä»¶', 'error');
                return;
            }
            
            const result = transformData();
            
            // æ„å»º CSV
            const headers = targetColumns.map(col => col.name);
            let csv = '\ufeff'; // UTF-8 BOM
            csv += headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',') + '\n';
            
            result.forEach(row => {
                const values = headers.map(h => {
                    const val = (row[h] || '').toString();
                    return `"${val.replace(/"/g, '""')}"`;
                });
                csv += values.join(',') + '\n';
            });
            
            // ä¸‹è½½
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `è½¬æ¢ç»“æœ_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast(`æˆåŠŸå¯¼å‡º ${result.length} æ¡è®°å½•`, 'success');
        }

        // ============== è§„åˆ™è‡ªæ£€ ==============
        let currentCheckColumn = null;
        let ruleCheckResults = {};

        function checkRules() {
            if (sourceData.length === 0) {
                showToast('è¯·å…ˆä¸Šä¼ æºæ•°æ®æ–‡ä»¶', 'error');
                return;
            }
            
            if (targetColumns.length === 0) {
                showToast('è¯·å…ˆé…ç½®è¾“å‡ºåˆ—', 'error');
                return;
            }

            // åˆ†ææ¯åˆ—çš„æ˜ å°„æƒ…å†µ
            ruleCheckResults = {};
            let totalUnmapped = 0;
            let totalMapped = 0;

            targetColumns.forEach(col => {
                const colName = col.name;
                const rule = mappingRules[colName];
                
                if (!rule || rule.type === 'fixed') {
                    // å›ºå®šå€¼è§„åˆ™ï¼Œæ‰€æœ‰æ•°æ®éƒ½ç®—æ˜ å°„æˆåŠŸ
                    ruleCheckResults[colName] = { mapped: sourceData.length, unmapped: [], type: 'fixed' };
                    totalMapped += sourceData.length;
                    return;
                }

                const unmapped = [];
                const mapped = [];

                sourceData.forEach((row, rowIndex) => {
                    const result = applyRuleForCheck(row, rule, rowIndex);
                    if (result.isMapped) {
                        mapped.push({ row, rowIndex, value: result.value });
                    } else {
                        unmapped.push({ row, rowIndex, sourceValue: result.sourceValue, reason: result.reason });
                    }
                });

                ruleCheckResults[colName] = { 
                    mapped: mapped.length, 
                    unmapped: unmapped,
                    type: rule.type
                };
                totalMapped += mapped.length;
                totalUnmapped += unmapped.length;
            });

            // æ˜¾ç¤ºå¼¹çª—
            showRuleCheckModal(totalMapped, totalUnmapped);
        }

        function applyRuleForCheck(row, rule, rowIndex) {
            const sourceCol = rule.sourceColumn;
            let sourceValue = sourceCol ? (row[sourceCol] || '') : '';

            switch (rule.type) {
                case 'direct':
                    return { isMapped: !!sourceValue, value: sourceValue, sourceValue, reason: sourceValue ? null : 'æºå€¼ä¸ºç©º' };
                
                case 'date':
                    if (!sourceValue) return { isMapped: false, sourceValue, reason: 'æ—¥æœŸä¸ºç©º' };
                    return { isMapped: true, value: sourceValue, sourceValue };
                
                case 'amount':
                    if (!sourceValue) return { isMapped: false, sourceValue, reason: 'é‡‘é¢ä¸ºç©º' };
                    return { isMapped: true, value: sourceValue, sourceValue };
                
                case 'valueMap':
                    const mappings = rule.mappings || {};
                    if (mappings[sourceValue]) {
                        return { isMapped: true, value: mappings[sourceValue], sourceValue };
                    }
                    return { isMapped: false, sourceValue, reason: 'æ— åŒ¹é…æ˜ å°„' };
                
                case 'fuzzyMap':
                    const fuzzyMappings = rule.fuzzyMappings || [];
                    for (const fm of fuzzyMappings) {
                        if (fm.contains && sourceValue.includes(fm.contains)) {
                            return { isMapped: true, value: fm.mapTo, sourceValue };
                        }
                    }
                    return { isMapped: false, sourceValue, reason: 'æ— åŒ¹é…å…³é”®è¯' };
                
                case 'expression':
                    // è¡¨è¾¾å¼é»˜è®¤è®¤ä¸ºæ˜¯æˆåŠŸçš„
                    return { isMapped: true, value: '', sourceValue };
                
                case 'combinedCondition':
                    const rules = rule.combinedConditions || [];
                    for (const r of rules) {
                        const conditions = r.conditions || [];
                        if (conditions.length === 0) continue;
                        
                        const allMatch = conditions.every(cond => {
                            const condSourceVal = cond.sourceColumn ? (row[cond.sourceColumn] || '') : '';
                            switch (cond.type) {
                                case 'timeRange':
                                    const timeMatch = condSourceVal.match(/(\d{1,2}):(\d{2})/);
                                    if (!timeMatch) return false;
                                    const hour = parseInt(timeMatch[1]);
                                    const minute = parseInt(timeMatch[2]);
                                    const timeMinutes = hour * 60 + minute;
                                    const [startH, startM] = (cond.startTime || '00:00').split(':').map(Number);
                                    const [endH, endM] = (cond.endTime || '23:59').split(':').map(Number);
                                    const startMinutes = startH * 60 + startM;
                                    const endMinutes = endH * 60 + endM;
                                    return timeMinutes >= startMinutes && timeMinutes <= endMinutes;
                                case 'contains':
                                    if (!cond.value) return false;
                                    const keywords = cond.value.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);
                                    return keywords.some(keyword => condSourceVal.includes(keyword));
                                case 'containsAll':
                                    if (!cond.value) return false;
                                    const allKeywords = cond.value.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);
                                    return allKeywords.every(keyword => condSourceVal.includes(keyword));
                                case 'equals':
                                    return condSourceVal === cond.value;
                                case 'startsWith':
                                    return cond.value && condSourceVal.startsWith(cond.value);
                                case 'regex':
                                    if (!cond.value) return false;
                                    try {
                                        return new RegExp(cond.value, 'i').test(condSourceVal);
                                    } catch (e) { return false; }
                                default:
                                    return false;
                            }
                        });

                        if (allMatch) {
                            return { isMapped: true, value: r.targetValue, sourceValue };
                        }
                    }
                    return { isMapped: false, sourceValue, reason: 'æ— åŒ¹é…è§„åˆ™' };
                
                default:
                    return { isMapped: false, sourceValue, reason: 'æœªçŸ¥è§„åˆ™ç±»å‹' };
            }
        }

        function showRuleCheckModal(totalMapped, totalUnmapped) {
            const modal = document.getElementById('ruleCheckModal');
            const summary = document.getElementById('ruleCheckSummary');
            const content = document.getElementById('ruleCheckContent');

            const total = sourceData.length * targetColumns.length;
            const mappedPercent = total > 0 ? ((totalMapped / total) * 100).toFixed(1) : 0;

            // ç»Ÿè®¡æ¦‚è§ˆ
            summary.innerHTML = `
                <div class="rule-check-stat">
                    <div class="stat-value">${sourceData.length}</div>
                    <div class="stat-label">æ€»è®°å½•æ•°</div>
                </div>
                <div class="rule-check-stat">
                    <div class="stat-value stat-success">${mappedPercent}%</div>
                    <div class="stat-label">æ˜ å°„æˆåŠŸç‡</div>
                </div>
                <div class="rule-check-stat">
                    <div class="stat-value ${totalUnmapped > 0 ? 'stat-warning' : 'stat-success'}">${totalUnmapped}</div>
                    <div class="stat-label">æœªæ˜ å°„é¡¹</div>
                </div>
            `;

            // åˆ—æ ‡ç­¾
            const columnsWithIssues = targetColumns.filter(col => 
                ruleCheckResults[col.name]?.unmapped?.length > 0
            );

            if (columnsWithIssues.length === 0) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--accent-green);">
                        <div style="font-size: 3rem;">âœ“</div>
                        <div style="font-size: 1.2rem; margin-top: 16px;">æ‰€æœ‰è§„åˆ™é…ç½®å®Œæ•´ï¼Œæ²¡æœ‰æœªæ˜ å°„çš„æ•°æ®ï¼</div>
                    </div>
                `;
            } else {
                currentCheckColumn = columnsWithIssues[0].name;
                content.innerHTML = renderRuleCheckContent(columnsWithIssues);
            }

            modal.classList.add('active');
            
            // Re-render modal for mobile overlay to recalculate
            document.body.classList.add('modal-open'); 
        }

        function renderRuleCheckContent(columnsWithIssues) {
            const tabs = columnsWithIssues.map(col => {
                const result = ruleCheckResults[col.name];
                const count = result?.unmapped?.length || 0;
                const isActive = col.name === currentCheckColumn;
                return `
                    <div class="column-tab has-issues ${isActive ? 'active' : ''}" 
                         onclick="switchCheckColumn('${escapeHtml(col.name)}')">
                        ${escapeHtml(col.name)}
                        <span class="tab-count">${count}</span>
                    </div>
                `;
            }).join('');

            const result = ruleCheckResults[currentCheckColumn];
            const rule = mappingRules[currentCheckColumn];

            // æŒ‰æºå€¼åˆ†ç»„ç»Ÿè®¡æœªæ˜ å°„é¡¹
            const grouped = {};
            (result?.unmapped || []).forEach(item => {
                const key = item.sourceValue || '(ç©ºå€¼)';
                if (!grouped[key]) {
                    grouped[key] = { count: 0, rows: [], sourceValue: item.sourceValue };
                }
                grouped[key].count++;
                grouped[key].rows.push(item.rowIndex);
            });

            // æŒ‰å‡ºç°æ¬¡æ•°æ’åº
            const sortedGroups = Object.entries(grouped)
                .sort((a, b) => b[1].count - a[1].count);

            const listHtml = sortedGroups.map(([key, data]) => {
                const preview = data.rows.slice(0, 3).map(i => i + 1).join(', ');
                const moreCount = data.rows.length > 3 ? `ç­‰${data.rows.length}æ¡` : '';
                
                return `
                    <div class="unmapped-item">
                        <div class="unmapped-info">
                            <div class="unmapped-value" title="${escapeHtml(key)}">${escapeHtml(key)}</div>
                            <div class="unmapped-detail">è¡Œå·: ${preview} ${moreCount}</div>
                        </div>
                        <span class="unmapped-count">${data.count}æ¡</span>
                        <div class="quick-add-form">
                            <span>â†’</span>
                            <input type="text" id="quickMap_${escapeHtml(data.sourceValue)}" 
                                   placeholder="æ˜ å°„ä¸º..." 
                                   onkeypress="if(event.key==='Enter')quickAddMapping('${escapeHtml(currentCheckColumn)}', '${escapeHtml(data.sourceValue)}', this.value)">
                            <button class="btn btn-sm btn-primary" 
                                    onclick="quickAddMapping('${escapeHtml(currentCheckColumn)}', '${escapeHtml(data.sourceValue)}', document.getElementById('quickMap_${escapeHtml(data.sourceValue)}').value)">
                                æ·»åŠ 
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="column-tabs">${tabs}</div>
                <div style="margin-bottom: 12px; color: var(--text-muted);">
                    è§„åˆ™ç±»å‹: <strong>${getRuleTypeName(rule?.type || 'none')}</strong>
                    ${rule?.sourceColumn ? ` | æºåˆ—: <strong>${escapeHtml(rule.sourceColumn)}</strong>` : ''}
                </div>
                <div class="unmapped-list">${listHtml}</div>
            `;
        }

        function switchCheckColumn(colName) {
            currentCheckColumn = colName;
            const columnsWithIssues = targetColumns.filter(col => 
                ruleCheckResults[col.name]?.unmapped?.length > 0
            );
            document.getElementById('ruleCheckContent').innerHTML = renderRuleCheckContent(columnsWithIssues);
        }

        function quickAddMapping(colName, sourceValue, targetValue) {
            if (!targetValue || !targetValue.trim()) {
                showToast('è¯·è¾“å…¥æ˜ å°„ç›®æ ‡å€¼', 'error');
                return;
            }

            const rule = mappingRules[colName];
            if (!rule) {
                showToast('è¯·å…ˆé…ç½®è¯¥åˆ—çš„æ˜ å°„è§„åˆ™', 'error');
                return;
            }

            targetValue = targetValue.trim();

            // æ ¹æ®è§„åˆ™ç±»å‹æ·»åŠ æ˜ å°„
            switch (rule.type) {
                case 'valueMap':
                    if (!rule.mappings) rule.mappings = {};
                    rule.mappings[sourceValue] = targetValue;
                    showToast(`å·²æ·»åŠ æ˜ å°„: "${sourceValue}" â†’ "${targetValue}"`, 'success');
                    break;
                
                case 'fuzzyMap':
                    if (!rule.fuzzyMappings) rule.fuzzyMappings = [];
                    rule.fuzzyMappings.push({ contains: sourceValue, mapTo: targetValue });
                    showToast(`å·²æ·»åŠ æ¨¡ç³Šæ˜ å°„: åŒ…å«"${sourceValue}" â†’ "${targetValue}"`, 'success');
                    break;
                
                case 'combinedCondition':
                    if (!rule.combinedConditions) rule.combinedConditions = [];
                    // æ·»åŠ ä¸€ä¸ªç®€å•çš„åŒ…å«æ¡ä»¶è§„åˆ™
                    rule.combinedConditions.push({
                        conditions: [{
                            type: 'contains',
                            sourceColumn: rule.sourceColumn,
                            value: sourceValue
                        }],
                        targetValue: targetValue
                    });
                    showToast(`å·²æ·»åŠ ç»„åˆè§„åˆ™: åŒ…å«"${sourceValue}" â†’ "${targetValue}"`, 'success');
                    break;
                
                default:
                    showToast('å½“å‰è§„åˆ™ç±»å‹ä¸æ”¯æŒå¿«é€Ÿæ·»åŠ æ˜ å°„', 'error');
                    return;
            }

            // é‡æ–°æ£€æŸ¥å¹¶åˆ·æ–°æ˜¾ç¤º
            checkRules();
            renderMappingList();
        }

        function closeRuleCheckModal() {
            document.getElementById('ruleCheckModal').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // ============== é…ç½®æ–¹æ¡ˆç®¡ç† ==============
        let currentPresetId = ''; // å½“å‰é€‰ä¸­çš„é…ç½®æ–¹æ¡ˆ ID

        // åˆå§‹åŒ–é…ç½®æ–¹æ¡ˆé€‰æ‹©å™¨
        function initPresetSelector() {
            const select = document.getElementById('presetSelect');
            select.innerHTML = '<option value="">-- é€‰æ‹©é…ç½®æ–¹æ¡ˆ --</option>';
            
            Object.keys(presets).forEach(id => {
                const preset = presets[id];
                const option = document.createElement('option');
                option.value = id;
                option.textContent = preset.name || id;
                select.appendChild(option);
            });

            // å¦‚æœæœ‰å½“å‰é€‰ä¸­çš„æ–¹æ¡ˆï¼Œä¿æŒé€‰ä¸­çŠ¶æ€
            if (currentPresetId && presets[currentPresetId]) {
                select.value = currentPresetId;
            }
        }

        // é…ç½®é€‰æ‹©å˜åŒ–æ—¶
        function onPresetSelectChange() {
            const presetId = document.getElementById('presetSelect').value;
            currentPresetId = presetId;
        }

        // åº”ç”¨é€‰ä¸­çš„é…ç½®æ–¹æ¡ˆ
        function applySelectedPreset() {
            const presetId = document.getElementById('presetSelect').value;
            if (!presetId || !presets[presetId]) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé…ç½®æ–¹æ¡ˆ', 'error');
                return;
            }
            
            currentPresetId = presetId;
            const preset = presets[presetId];
            document.getElementById('skipRows').value = preset.skipRows || 0;
            targetColumns = JSON.parse(JSON.stringify(preset.targetColumns || []));
            mappingRules = JSON.parse(JSON.stringify(preset.mappingRules || {}));
            
            renderTargetColumns();
            renderMappingList();
            
            if (rawFileContent) {
                parseSourceData();
            }
            
            showToast(`å·²åº”ç”¨é…ç½®ï¼š${preset.name}`, 'success');
        }

        // å°†å½“å‰é…ç½®ä¿å­˜ä¸ºæ–°æ–¹æ¡ˆ
        function saveAsNewPreset() {
            const name = prompt('è¯·è¾“å…¥æ–°é…ç½®æ–¹æ¡ˆçš„åç§°ï¼š', 'æˆ‘çš„é…ç½®');
            if (!name || !name.trim()) return;
            
            // ç”Ÿæˆå”¯ä¸€ ID
            const id = 'custom-' + Date.now();
            
            presets[id] = {
                name: name.trim(),
                skipRows: parseInt(document.getElementById('skipRows').value) || 0,
                targetColumns: JSON.parse(JSON.stringify(targetColumns)),
                mappingRules: JSON.parse(JSON.stringify(mappingRules))
            };
            
            currentPresetId = id;
            initPresetSelector();
            document.getElementById('presetSelect').value = id;
            
            showToast(`é…ç½®æ–¹æ¡ˆ "${name}" å·²åˆ›å»º`, 'success');
        }

        // é‡å‘½åå½“å‰æ–¹æ¡ˆ
        function renamePreset() {
            if (!currentPresetId || !presets[currentPresetId]) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé…ç½®æ–¹æ¡ˆ', 'error');
                return;
            }
            
            const oldName = presets[currentPresetId].name;
            const newName = prompt('è¯·è¾“å…¥æ–°åç§°ï¼š', oldName);
            if (!newName || !newName.trim() || newName === oldName) return;
            
            presets[currentPresetId].name = newName.trim();
            initPresetSelector();
            
            showToast(`å·²é‡å‘½åä¸º "${newName}"`, 'success');
        }

        // åˆ é™¤å½“å‰æ–¹æ¡ˆ
        function deletePreset() {
            if (!currentPresetId || !presets[currentPresetId]) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé…ç½®æ–¹æ¡ˆ', 'error');
                return;
            }
            
            const name = presets[currentPresetId].name;
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é…ç½®æ–¹æ¡ˆ "${name}" å—ï¼Ÿ\n\nåˆ é™¤åéœ€è¦"ä¿å­˜åˆ°HTML"æ‰èƒ½æ°¸ä¹…ç”Ÿæ•ˆã€‚`)) {
                return;
            }
            
            delete presets[currentPresetId];
            currentPresetId = '';
            initPresetSelector();
            
            showToast(`é…ç½®æ–¹æ¡ˆ "${name}" å·²åˆ é™¤`, 'success');
        }

        // å¯¼å‡ºå½“å‰é…ç½®ä¸º JSON
        function exportConfig() {
            if (targetColumns.length === 0) {
                showToast('è¯·å…ˆé…ç½®ç›®æ ‡åˆ—', 'error');
                return;
            }

            const config = {
                name: currentPresetId && presets[currentPresetId] ? presets[currentPresetId].name : 'å¯¼å‡ºçš„é…ç½®',
                skipRows: parseInt(document.getElementById('skipRows').value),
                targetColumns: targetColumns,
                mappingRules: mappingRules,
                exportedAt: new Date().toISOString()
            };
            
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `è´¦å•è½¬æ¢é…ç½®_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('é…ç½®å·²å¯¼å‡ºä¸º JSON æ–‡ä»¶', 'success');
        }

        // å°†æ‰€æœ‰é…ç½®æ–¹æ¡ˆä¿å­˜åˆ° HTML æ–‡ä»¶
        function saveRulesToHtml() {
            try {
                if (Object.keys(presets).length === 0) {
                    showToast('æ²¡æœ‰é…ç½®æ–¹æ¡ˆå¯ä¿å­˜', 'error');
                    return;
                }

                // å¦‚æœå½“å‰æœ‰ç¼–è¾‘ä¸­çš„é…ç½®ï¼Œè¯¢é—®æ˜¯å¦æ›´æ–°åˆ°å½“å‰æ–¹æ¡ˆ
                if (currentPresetId && presets[currentPresetId] && targetColumns.length > 0) {
                    if (confirm('æ˜¯å¦å°†å½“å‰ç¼–è¾‘çš„é…ç½®æ›´æ–°åˆ°é€‰ä¸­çš„æ–¹æ¡ˆï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"æ›´æ–°ï¼Œç‚¹å‡»"å–æ¶ˆ"ä»…ä¿å­˜å·²æœ‰æ–¹æ¡ˆã€‚')) {
                        presets[currentPresetId] = {
                            ...presets[currentPresetId],
                            skipRows: parseInt(document.getElementById('skipRows').value) || 0,
                            targetColumns: JSON.parse(JSON.stringify(targetColumns)),
                            mappingRules: JSON.parse(JSON.stringify(mappingRules))
                        };
                    }
                }

                // æ›´æ–° DOM ä¸­çš„é…ç½®æ ‡ç­¾
                const presetScript = document.getElementById('preset-config');
                if (!presetScript) {
                    showToast('æ— æ³•æ‰¾åˆ°é…ç½®å­˜å‚¨ä½ç½®', 'error');
                    return;
                }

                // ä¿å­˜åŸå§‹é…ç½®ç”¨äºæ¢å¤
                const originalContent = presetScript.textContent;
                
                // æ›´æ–°é…ç½®å†…å®¹ï¼ˆä¿å­˜æ‰€æœ‰æ–¹æ¡ˆï¼‰
                presetScript.textContent = '\n' + JSON.stringify(presets, null, 4) + '\n    ';

                // è·å–å®Œæ•´çš„ HTMLï¼ˆåŒ…æ‹¬ DOCTYPEï¼‰
                const doctype = '<!DOCTYPE html>\n';
                const htmlContent = doctype + document.documentElement.outerHTML;

                // æ¢å¤åŸå§‹é…ç½®ï¼ˆé¿å…å½±å“å½“å‰é¡µé¢çŠ¶æ€ï¼‰
                presetScript.textContent = originalContent;

                // ä¸‹è½½æ–°çš„ HTML æ–‡ä»¶
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().slice(0, 10);
                a.download = `excel-converter-${timestamp}.html`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

                const count = Object.keys(presets).length;
                showToast(`å·²ä¿å­˜ ${count} ä¸ªé…ç½®æ–¹æ¡ˆåˆ° HTML æ–‡ä»¶`, 'success');
            } catch (error) {
                console.error('ä¿å­˜å¤±è´¥:', error);
                showToast('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ç”Ÿæˆé¢„è®¾é…ç½®çš„ JavaScript ä»£ç 
        function generatePresetsCode(preset) {
            const indent = '            ';
            const indent2 = '                ';
            const indent3 = '                    ';
            const indent4 = '                        ';

            let code = 'const presets = {\n';
            code += `${indent}'meituan-pixiu': {\n`;
            code += `${indent2}name: '${preset.name}',\n`;
            code += `${indent2}skipRows: ${preset.skipRows},\n`;

            // targetColumns
            code += `${indent2}targetColumns: [\n`;
            preset.targetColumns.forEach((col, i) => {
                const comma = i < preset.targetColumns.length - 1 ? ',' : '';
                code += `${indent3}{ name: '${escapeJsString(col.name)}', defaultValue: '${escapeJsString(col.defaultValue || '')}' }${comma}\n`;
            });
            code += `${indent2}],\n`;

            // mappingRules
            code += `${indent2}mappingRules: {\n`;
            const ruleKeys = Object.keys(preset.mappingRules);
            ruleKeys.forEach((key, keyIndex) => {
                const rule = preset.mappingRules[key];
                const isLastKey = keyIndex === ruleKeys.length - 1;
                code += generateRuleCode(key, rule, indent3, indent4, isLastKey);
            });
            code += `${indent2}}\n`;

            code += `${indent}}\n`;
            code += '        };';

            return code;
        }

        // ç”Ÿæˆå•ä¸ªè§„åˆ™çš„ä»£ç 
        function generateRuleCode(key, rule, indent, indent2, isLast) {
            let code = `${indent}'${escapeJsString(key)}': {\n`;
            code += `${indent2}type: '${rule.type}'`;

            switch (rule.type) {
                case 'direct':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    break;

                case 'date':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    code += `,\n${indent2}dateFormat: '${escapeJsString(rule.dateFormat || 'YYYY-MM-DD')}'`;
                    break;

                case 'amount':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    break;

                case 'fixed':
                    code += `,\n${indent2}fixedValue: '${escapeJsString(rule.fixedValue || '')}'`;
                    break;

                case 'valueMap':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    code += `,\n${indent2}mappings: ${JSON.stringify(rule.mappings || {}, null, 0).replace(/"/g, "'")}`;
                    break;

                case 'fuzzyMap':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    code += `,\n${indent2}fuzzyMappings: [\n`;
                    (rule.fuzzyMappings || []).forEach((fm, i) => {
                        const comma = i < rule.fuzzyMappings.length - 1 ? ',' : '';
                        code += `${indent2}    { contains: '${escapeJsString(fm.contains || '')}', mapTo: '${escapeJsString(fm.mapTo || '')}' }${comma}\n`;
                    });
                    code += `${indent2}]`;
                    break;

                case 'expression':
                    code += `,\n${indent2}expression: '${escapeJsString(rule.expression || '')}'`;
                    break;

                case 'combinedCondition':
                    code += `,\n${indent2}sourceColumn: '${escapeJsString(rule.sourceColumn || '')}'`;
                    code += `,\n${indent2}combinedConditions: [\n`;
                    (rule.combinedConditions || []).forEach((cc, i) => {
                        const comma = i < rule.combinedConditions.length - 1 ? ',' : '';
                        code += `${indent2}    { conditions: ${generateConditionsCode(cc.conditions)}, targetValue: '${escapeJsString(cc.targetValue || '')}' }${comma}\n`;
                    });
                    code += `${indent2}]`;
                    break;
            }

            code += `\n${indent}}${isLast ? '' : ','}\n`;
            return code;
        }

        // ç”Ÿæˆæ¡ä»¶æ•°ç»„ä»£ç 
        function generateConditionsCode(conditions) {
            if (!conditions || conditions.length === 0) return '[]';
            
            const parts = conditions.map(cond => {
                let condCode = `{ type: '${cond.type}'`;
                if (cond.sourceColumn) {
                    condCode += `, sourceColumn: '${escapeJsString(cond.sourceColumn)}'`;
                }
                if (cond.type === 'timeRange') {
                    condCode += `, startTime: '${cond.startTime || '00:00'}', endTime: '${cond.endTime || '23:59'}'`;
                } else if (cond.value !== undefined) {
                    condCode += `, value: '${escapeJsString(cond.value)}'`;
                }
                condCode += ' }';
                return condCode;
            });
            
            return '[' + parts.join(', ') + ']';
        }

        // è½¬ä¹‰ JavaScript å­—ç¬¦ä¸²ä¸­çš„ç‰¹æ®Šå­—ç¬¦
        function escapeJsString(str) {
            if (typeof str !== 'string') return '';
            return str
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
        }

        function importConfig() {
            document.getElementById('configImportInput').click();
        }

        document.getElementById('configImportInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const config = JSON.parse(event.target.result);
                    
                    if (!config.targetColumns || !config.mappingRules) {
                        throw new Error('é…ç½®æ–‡ä»¶æ ¼å¼æ— æ•ˆ');
                    }
                    
                    // è¯¢é—®æ˜¯ç›´æ¥åº”ç”¨è¿˜æ˜¯ä¿å­˜ä¸ºæ–°æ–¹æ¡ˆ
                    const action = confirm('å¦‚ä½•å¤„ç†å¯¼å…¥çš„é…ç½®ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"ï¼šä¿å­˜ä¸ºæ–°çš„é…ç½®æ–¹æ¡ˆ\nç‚¹å‡»"å–æ¶ˆ"ï¼šä»…ä¸´æ—¶åº”ç”¨ï¼ˆä¸ä¿å­˜ï¼‰');
                    
                    if (action) {
                        // ä¿å­˜ä¸ºæ–°æ–¹æ¡ˆ
                        const name = config.name || 'å¯¼å…¥çš„é…ç½®';
                        const id = 'imported-' + Date.now();
                        presets[id] = {
                            name: name,
                            skipRows: config.skipRows || 0,
                            targetColumns: config.targetColumns,
                            mappingRules: config.mappingRules
                        };
                        currentPresetId = id;
                        initPresetSelector();
                        document.getElementById('presetSelect').value = id;
                        showToast(`å·²å¯¼å…¥å¹¶ä¿å­˜ä¸ºé…ç½®æ–¹æ¡ˆ "${name}"`, 'success');
                    }
                    
                    // åº”ç”¨é…ç½®
                    document.getElementById('skipRows').value = config.skipRows || 0;
                    targetColumns = config.targetColumns;
                    mappingRules = config.mappingRules;
                    
                    renderTargetColumns();
                    renderMappingList();
                    
                    if (rawFileContent) {
                        parseSourceData();
                    }
                    
                    if (!action) {
                        showToast('é…ç½®å·²ä¸´æ—¶åº”ç”¨', 'success');
                    }
                } catch (err) {
                    showToast('é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼š' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        // ============== å·¥å…·å‡½æ•° ==============
        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100px)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ============== åˆå§‹åŒ– ==============
        function init() {
            initPresetSelector();
            renderTargetColumns();
            renderMappingList();
        }

        init();
    </script>
<script type="module" src="/index.tsx"></script>
</body></html>
    </div>
    
    <!-- App æ¨å¹¿æµ®çª— -->
<style>
  #app-promo {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100px;
    background: #fff;
    border-top: 1px solid #ddd;
    box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    font-family: sans-serif;
    z-index: 9999;
    box-sizing: border-box;
  }
  #app-promo img {
    width: 64px;
    height: 64px;
    border-radius: 12px;
    object-fit: cover;
  }
  #app-promo-content {
    flex: 1;
    margin-left: 12px;
    padding-right: 8px;
  }
  #app-promo-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 4px;
    color: #333;
  }
  #app-promo-desc {
    font-size: 14px;
    color: #666;
  }
  #app-promo-close {
    font-size: 24px;
    color: #aaa;
    cursor: pointer;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
    margin-left: 12px;
    margin-right: 4px;
    transition: background 0.2s;
  }
  #app-promo-close:active {
    background: rgba(0,0,0,0.1);
    border-radius: 50%;
  }

  @media (max-width: 480px) {
    #app-promo {
      height: 80px;
      padding: 8px 12px;
    }
    #app-promo img {
      width: 48px;
      height: 48px;
      border-radius: 8px;
    }
    #app-promo-title {
      font-size: 15px;
    }
    #app-promo-desc {
      font-size: 13px;
    }
    #app-promo-close {
      font-size: 22px;
      width: 40px;
      height: 40px;
    }
  }
</style>

<!-- App æ¨å¹¿æµ®çª— -->
<div id="app-promo">
  <img src="http://pplane.anzhai.space/web_pan_icon.png" alt="App Icon">
  <div id="app-promo-content">
    <div id="app-promo-title">WebPan</div>
    <div id="app-promo-desc">ä¸€æ¬¾HTMLä»£ç ç¼–è¾‘ä¸é¢„è§ˆå·¥å…·</div>
  </div>
  <div id="app-promo-close">&times;</div>
</div>

<script>
  // ç‚¹å‡»å…³é—­æŒ‰é’®
  document.getElementById('app-promo-close').addEventListener('click', function(e) {
    e.stopPropagation();  // é˜»æ­¢äº‹ä»¶å†’æ³¡
    document.getElementById('app-promo').style.display = 'none';
  });

  // ç‚¹å‡»æµ®çª—è·³è½¬ App Store
  document.getElementById('app-promo').addEventListener('click', function(e) {
    if (e.target.id !== 'app-promo-close') {
      window.open('https://apps.apple.com/app/id6749603694', '_blank');
    }
  });
</script>


</body>
</html>
