<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>zhisheng|😉</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="zhisheng|😉" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">zhisheng|😉</a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2019/09/25/「条件队列」探索/"></a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-09-25</span><br />
		
		
	</div>

	

	
		<h1 id="「条件队列」探索"><a href="#「条件队列」探索" class="headerlink" title="「条件队列」探索"></a>「条件队列」探索</h1><h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><p>条件谓词：使某个操作成为状态依赖操作的前提条件。比如容器的<code>isFull</code>等判断。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li><p>定义：一组线程能够通过某种方式等待特点条件变成真，“这组队列和对应的条件等待机制”可以组合称为「条件队列」（此处定义为我的理解，也可以说一个等待机制就是条件队列，因为线程和具体条件都是可变更的），这是一个稍微抽象的概念，传统的队列中的元素都是一个个数据，而条件队列中的元素是一个个正在等待相关条件的线程。</p>
</li>
<li><p>举例：</p>
<ol>
<li><p>每个 Java 对象都能作为一个锁，每一个Java 对象都能作为一个条件队列。</p>
</li>
<li><p><code>Object</code> 类的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法就构成了条件队列内部的API。</p>
</li>
<li><p>这里的重点是，为什么「每个 Java 对象 都能作为一个锁」和「每一个 Java 对象都能作为一个条件队列」有对应关系？<strong>因为「等待由状态构成的条件」与「维护状态一致性」这两种机制是绑定在一起的</strong>：</p>
<ol>
<li><strong>只有能对状态进行检查的时候，才能在某个条件上等待。</strong>    </li>
<li><strong>只有能修改条件的时候，才能够释放另外一个线程。</strong></li>
</ol>
<p>由此可以总结得到条件队列的<strong>三元关系</strong>（锁，条件谓词，条件变量）：</p>
<ol>
<li>在条件谓词中包含的变量必须要有锁来保护。</li>
<li>在检测条件谓词和使用<code>wait</code>（或<code>Condition</code>的<code>await</code>）和<code>notify</code>（或<code>Condition</code>的<code>signal</code>）的时候，必须持有锁。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><p>单线程的应用在调用一个方法时，如果依赖于某个基于状态构成的条件，比如某个布尔值是否为true，那么当时这个条件不为真，那么就永远不会为真，这个方法也就永远无法执行；但是，在并发程序中，基于状态的条件，有可能会由于其他线程的操作而发生改变，这很容易理解，因为其它线程是有可能会修改这些共享内存的，那么此时，当前线程等待前提条件成真，在进行下一步动作，不失为一个比较好的选择。</p>
<p>适用场景：多个线程都依赖于某个资源容器时，比如线程池中的阻塞队列就是依赖条件队列实现。</p>
<h2 id="原理机制"><a href="#原理机制" class="headerlink" title="原理机制"></a>原理机制</h2><p>参考《<strong>Java Concurrency In Practice</strong>》，我们从一个有限循环阻塞缓存的实现进化来探讨条件队列的实现机制。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>基础原型如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;</div><div class="line">        buf[tail] = v;</div><div class="line">        <span class="keyword">if</span> (++tail == buf.length) &#123;</div><div class="line">            tail = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        ++count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;</div><div class="line">        V v = buf[head];</div><div class="line">        buf[head] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++head == buf.length) &#123;</div><div class="line">            head = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        --count;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count == buf.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BaseBoundedBuffer</code>是一个抽象基类，具备基础的 <code>put</code> 和 <code>take</code> 方法，但是两个方法中都没有对当前缓存数组的有效数据长度进行判断，所以需要在子类中结合 <code>isFull</code> 方法和 <code>isEmpty</code> 方法来完善这个缓存类。</p>
<h3 id="V1-通过抛出异常来让调用方感知前提条件未达成"><a href="#V1-通过抛出异常来让调用方感知前提条件未达成" class="headerlink" title="V1 通过抛出异常来让调用方感知前提条件未达成"></a>V1 通过抛出异常来让调用方感知前提条件未达成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedHandleExceptionBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NeedHandleExceptionBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> BufferFullException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isFull()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferFullException();</div><div class="line">        &#125;</div><div class="line">        doPut(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> BufferEmptyException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferEmptyException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> doTake();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>NeedHandleExceptionBoundedBuffer</code>这个具体的缓存实现类中，我们在调用基类的<code>put</code>和<code>take</code>方法前，先判断了当前缓存是否已满或者是否有有效缓存存在，如果不满足前提条件，我们就抛出异常，让调用方来对缓存状态进行管理。这样做的优点是实现简单，但是却有着很明显的负面代价：</p>
<ol>
<li><strong>缓存已满</strong>和<strong>缓存为空</strong>这两个条件并不是缓存的异常条件，通过异常来透出这个信息是不合理的，违背了异常的使用规范。</li>
<li><p>让调用方来管理状态依赖，对调用方来说是比较严重的负担，调用方在使用该缓存时需要进行如下的包装，从代码品味的角度来看，是比较难以让人接受的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    V item = buffer.take();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;<span class="keyword">catch</span>(BufferEmptyException ex)&#123;</div><div class="line">    Thread.sleep(xx);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们可以把这部分包装逻辑移到缓存内部中，这就得到了我们更好的一个缓存实现版本，具体细节往下看。</p>
</li>
</ol>
<h3 id="V2-通过轮询和休眠实现阻塞"><a href="#V2-通过轮询和休眠实现阻塞" class="headerlink" title="V2 通过轮询和休眠实现阻塞"></a>V2 通过轮询和休眠实现阻塞</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> SLEEP_GRANULARITY = <span class="number">1000L</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (!isFull()) &#123;</div><div class="line">                    doPut(v);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Thread.sleep(SLEEP_GRANULARITY);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (!isEmpty()) &#123;</div><div class="line">                    <span class="keyword">return</span> doTake();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Thread.sleep(SLEEP_GRANULARITY);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个版本中，我们在缓存的内部实现了前置条件的轮询检查和阻塞，相比上一个版本好了很多，起码调用者不用在感知缓存内部的状态依赖细节，调用更加简单，也没有别扭的使用异常。但是同样也新增了额外的问题：</p>
<ol>
<li>使用方需要处理可能的<code>InterruptedException</code>。</li>
<li>在线程<code>sleep</code>期间，条件有可能正好已经满足，但是线程却无法及时响应，当线程恢复时，可能条件又不再满足，适用方需要很好的权衡<code>SLEEP_GRANULARITY</code>的大小，使<strong>响应性</strong>和<strong>CPU使用率</strong>达到一个可接受的平衡。</li>
</ol>
<p>上述几种实现方式，都很难尽善尽美，如果存在一种挂起线程的方法，并且这种方法能够确保当某个条件成真时线程立即醒来，那么将极大地简化实现工作，这就是下面要说的条件队列。</p>
<h3 id="V3-通过内置条件队列实现"><a href="#V3-通过内置条件队列实现" class="headerlink" title="V3 通过内置条件队列实现"></a>V3 通过内置条件队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (isFull())</div><div class="line">            wait();</div><div class="line">        doPut(v);</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (isEmpty())</div><div class="line">            wait();</div><div class="line">        V v = doTake();</div><div class="line">        notifyAll();</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的实现代码中，我们使用了对象内置的 <code>wait</code>和<code>notifyAll</code>方法来实现了有界循环阻塞缓存，相比于 V2 ，V3 版本的实现更加高效：线程多余的唤醒更少，在前置条件变更时也能更及时的醒来。但是，同样仍然还有优化的余地：</p>
<p><code>notifyAll</code>会尝试唤醒当前在该对象内置锁上等待的所有线程，不论这个线程等待的前置条件是<code>isFull</code>还是<code>isEmpty</code>，这样会导致多余的上下文切换，究其本质原因，是因为内置条件队列本身的限制：每个内置锁只能有一个相关联的条件队列，所以会存在多个线程在同一个条件队列上等待不同的条件谓词的情况。要想解决这个问题，我们可以使用显示的<code>Lock</code>和对应的<code>Condition</code>而不是内置锁和条件队列来实现，接下来的V4版本将会介绍这种实现方式。</p>
<p>V3 中也提现了使用条件等待的一些要素：</p>
<blockquote>
<ol>
<li>有条件谓词；这一点已经在前面的三元关系中有提及。</li>
<li>在调用<code>wait</code>之前测试条件谓词，并且从<code>wait</code>中返回时再次进行测试。</li>
<li>在一个循环调用<code>wait</code>。</li>
<li>当调用<code>wait</code>，<code>notify</code>或<code>notifyAll</code>等方法时，一定要持有与条件队列相关的锁。</li>
<li>在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。</li>
</ol>
</blockquote>
<h3 id="V4-使用显示的condition对象实现"><a href="#V4-使用显示的condition对象实现" class="headerlink" title="V4 使用显示的condition对象实现"></a>V4 使用显示的<code>condition</code>对象实现</h3><p>与每个内置锁只能有一个相关联的条件队列不同，每个显示<code>Lock</code>，都可以有任意数量的<code>Condition</code>对象。</p>
<p>在<code>Condition</code>对象中，与<code>wait</code>，<code>notify</code>，<code>notifyAll</code>对应的方法是<code>await</code>，<code>signal</code>，<code>signalAll</code>，此处需要注意的是，因为<code>Condition</code>对象也继承了<code>Object</code>，所以其也会拥有<code>wait</code>，<code>notify</code> ，<code>notifyAll</code>三个方法，注意不要混用。</p>
<p>以下是具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBoundedBuffer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[]) <span class="keyword">new</span> Object[BUFFER_SIZE];</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail, head, count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == items.length) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            items[tail] = x;</div><div class="line">            <span class="keyword">if</span> (++tail == items.length) &#123;</div><div class="line">                tail = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            ++count;</div><div class="line">            notEmpty.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                notEmpty.await();</div><div class="line">            &#125;</div><div class="line">            T x = items[head];</div><div class="line">            items[head] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (++head == items.length) &#123;</div><div class="line">                head = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            --count;</div><div class="line">            notFull.signal();</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拿 V3 和 V4 比较，我们会发现，因为 V3 中使用的是内置条件队列，所有线程等待的都是用一个通知信号，所以必须使用<code>notifyAll</code>的方式来防止唤醒错误的等待线程，但是 V4 版本中，通过使用不同的<code>Condition</code>对象区分了两个等待线程集合，我们可以使用<code>signal</code>而不是<code>signalAll</code>来进行通知，这样只会唤起一个等待线程，更加高效；由此，我们可以总结得到一套是否能够使用单一通知的判断策略：</p>
<blockquote>
<ol>
<li>所有等待线程的类型都相同。即等待该通知的所有线程被唤醒后从<code>wait</code>恢复都执行了是同一套逻辑。</li>
<li>单进单出。最多只能唤醒一个线程来执行。</li>
</ol>
</blockquote>
<p>上述两个条件都满足的情况下可以选用单一通知。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/12/14/简单聊聊Spring中几种设计模式/">简单聊聊Spring中几种设计模式</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-12-14</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Java/">Java</a> <a class="article__tag-link" href="/tags/Spring/">Spring</a> <a class="article__tag-link" href="/tags/设计模式/">设计模式</a>
			</span>
		
	</div>

	

	
		<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在平时的Java项目开发过程中，综合稳定性与开发效率的考虑，我往往会使用Spring+SpringMVC+Spring DATA JPA 这样的技术选型，其中Spring部分主要是使用它的IOC和AOP,而SpringMVC则是Spring Framework的Web模块，Spring Data JPA则是Spring Framework提供的高度抽象的ORM框架。现实确实如此，现代的Java项目开发，Spring*几乎成为了标配以及最佳选择。</p>
<p>我因为使用Sping系列框架比较多，而且也因为其是开源框架，不涉及版权问题，所以这次的作业我就想基于Spring系列框架分析一下其中我比较了解的若干种设计模式的使用。</p>
<h2 id="1-工厂模式与控制反转"><a href="#1-工厂模式与控制反转" class="headerlink" title="1. 工厂模式与控制反转"></a>1. 工厂模式与控制反转</h2><p>Spring中，最核心，也是最出名的功能，就是<strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>）。</p>
<h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>在软件开发生命周期中，“耦合”是一个很常见的词，它描述了不同模块之间相互依赖，共同协作的一种情况，因为很像许多种齿轮耦合在一块工作，所以被简称为“耦合”。</p>
<p>耦合的坏处不言而喻，虽然产品最终能够工作，但是因为模块之间的依赖性过于强大，导致任何一个模块出现问题都会导致整个产品出现问题，如果项目愈发庞大，多重依赖的出现还会导致项目的发展运维出现问题，直接导致项目的崩溃。</p>
<figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/齿轮_耦合关系_full.jpg" alt="齿轮_耦合关系" title="齿轮_耦合关系"><figcaption class="figure__caption">齿轮_耦合关系</figcaption></figure>
<p>所以为了解决这用问题，就有了IoC</p>
<p>###1.2 何谓IoC</p>
<p>IoC的主要思想，就是通过使用第三方容器，来接触具有依赖关系的对象之间的耦合。</p>
<figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/齿轮_解耦合_full.jpg" alt="齿轮_解耦合" title="齿轮_解耦合"><figcaption class="figure__caption">齿轮_解耦合</figcaption></figure>
<p>通过使用一个第三方，来维护具有依赖关系的对象的生命周期，将原本需要主动获取对象产生依赖关系的情况，转变为由这个第三方来控制依赖关系，这样就巧妙的解除了耦合。</p>
<p>IoC是一种思想方式，而Spring中的IoC容器采用了<strong>依赖注入</strong> (DI)这种实现方式。</p>
<p>即通过将依赖对象注入到目标对象中的一种实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Son son;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(Son son)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.son = son;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如上述代码中的Father类，他对Son类有依赖，通过setSon方法，在外部构造好Son类实例传入，就完成了一次依赖注入。</p>
<h3 id="1-3-具体实现"><a href="#1-3-具体实现" class="headerlink" title="1.3 具体实现"></a>1.3 具体实现</h3><p>Spring中主要通过BeanFactory来实现IoC，BeanFactory的继承体系如下，比较复杂</p>
<figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/BeanFactory.png" alt="BeanFactory.png" title=""><figcaption class="figure__caption">BeanFactory.png</figcaption></figure>
<p>我们这里就只看看顶层BeanFactory接口的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.beans.factory;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 四个不同形式的getBean方法，获取实例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>; <span class="comment">// 是否存在</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;<span class="comment">// 是否为单实例</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;<span class="comment">// 是否为原型（多实例）</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; targetType)</span></span></div><div class="line"><span class="function">            <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;<span class="comment">// 名称、类型是否匹配</span></div><div class="line"></div><div class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException; <span class="comment">// 获取类型</span></div><div class="line"></div><div class="line">    String[] getAliases(String name);<span class="comment">// 根据实例的名字获取实例的别名</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以很清晰的理解BeanFactory的作用，这里一直在提到”Bean”这个东西，那到底什么是Bean呢？</p>
<p>JavaBeans是<strong>Java</strong>中一种特殊的类，可以将多个对象封装到一个对象（<strong>bean</strong>）中。 特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。 名称中的“<strong>Bean</strong>”是用于<strong>Java</strong>的可重用软件组件的惯用叫法。</p>
<p>通过配置xml，最新版的Spring也支持通过注解配置，Spring会帮助框架使用者管理所有有需要的类的生命周期，通过手动使用BeanFactory或者使用自动注入注解，就可以方便快速的注入依赖。</p>
<h3 id="1-4-示例"><a href="#1-4-示例" class="headerlink" title="1.4 示例"></a>1.4 示例</h3><p>首先编写一个简单的Javabean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Driver driver;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Driver <span class="title">getDriver</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> driver;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(Driver driver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.driver = driver;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"driver say \" "</span> + driver.selfIntroduction() + <span class="string">"\""</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Driver是一个接口，可以有不同的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">selfIntroduction</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadDriverImpl</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I am a bad driver."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodDriverImpl</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I am a good driver."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Car的表现会随着driver的不同而不同，很明显可以通过常规的工厂方法来封装car的构造过程, 在这里我们通过Spring来实现这一功能，首先编写xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>   <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodDriver"</span> <span class="attr">class</span>=<span class="string">"me.xubowei.springdemo.GoodDriverImpl"</span>/&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"badDriver"</span> <span class="attr">class</span>=<span class="string">"me.xubowei.springdemo.BadDriverImpl"</span>/&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodCar"</span> <span class="attr">class</span>=<span class="string">"me.xubowei.springdemo.Car"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"goodDriver"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"badCar"</span> <span class="attr">class</span>=<span class="string">"me.xubowei.springdemo.Car"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"badDriver"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在驱动函数进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</div><div class="line">        Car goodCar = (Car)applicationContext.getBean(<span class="string">"goodCar"</span>);</div><div class="line">        Car badCar = (Car)applicationContext.getBean(<span class="string">"badCar"</span>);</div><div class="line">        System.out.println(goodCar.selfIntroduction());</div><div class="line">        System.out.println(<span class="string">"---------------"</span>);</div><div class="line">        System.out.println(badCar.selfIntroduction());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中applicationContext是在BeanFactory继承体系中的一环，可以看做功能更为强大的工厂.</p>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">十二月 14, 2017 2:46:45 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh</div><div class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@728938a9: startup date [Thu Dec 14 14:46:45 CST 2017]; root of context hierarchy</div><div class="line">十二月 14, 2017 2:46:45 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</div><div class="line">信息: Loading XML bean definitions from class path resource [bean.xml]</div><div class="line"></div><div class="line">driver say &quot; I am a good driver.&quot;</div><div class="line">---------------</div><div class="line">driver say &quot; I am a bad driver.&quot;</div></pre></td></tr></table></figure>
<p>可以看到通过传入id名称，程序获取到了想要的资源文件，这便是spring中IoC的一个简单介绍。</p>
<h2 id="2-ApplicationContext与观察者模式"><a href="#2-ApplicationContext与观察者模式" class="headerlink" title="2. ApplicationContext与观察者模式"></a>2. ApplicationContext与观察者模式</h2><p>在上面介绍Spring中的IoC时，有提到ApplicationContext，它间接继承于BeanFactory，但是扩展了更多功能。ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能：<br>​        • MessageSource, 提供国际化的消息访问<br>​        • 资源访问，如URL和文件<br>​        • 事件传播<br>​        • 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </p>
<p>我们这里来看看它的事件传播功能。</p>
<h3 id="2-1-为什么要有事件传播"><a href="#2-1-为什么要有事件传播" class="headerlink" title="2.1 为什么要有事件传播"></a>2.1 为什么要有事件传播</h3><p>Spring中的IoC容器在控制依赖注入的同时，也需要控制注册在容器的对象的生命周期，生命周期的存在自然对应着不同的事件触发需求。</p>
<p>###2.2 代码结构</p>
<p>关键类的结构体系如下：</p>
<figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/Event.png" alt="Event.png" title=""><figcaption class="figure__caption">Event.png</figcaption></figure>
<p>ApplicationContext中维护着ApplicationListener列表，且ApplicationContext实现了ApplicationEventPublisher，所以其可以充当事件发布者；当有默认事件或框架使用者通过实现ApplicationEvent然后通过ApplicationContext触发后，ApplicationContext就会使用ApplicationEventMulticaster来触发监听器。</p>
<h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h3><p>一个自定义的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</div><div class="line">　　 <span class="keyword">private</span> String name;</div><div class="line">　　 <span class="keyword">private</span> String password;</div><div class="line">　　 <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source, String name, String password)</span></span>&#123;</div><div class="line">　　 		<span class="keyword">super</span>(source);</div><div class="line">　　　　　 <span class="keyword">this</span>.name = name;</div><div class="line">　　　　　 <span class="keyword">this</span>.password = password;</div><div class="line">　　 &#125;</div><div class="line">　　 <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source)</span> </span>&#123;</div><div class="line">　　　　　<span class="keyword">super</span>(source);</div><div class="line">　　 &#125;</div><div class="line">　　 <span class="comment">//......name和password的setter、getter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span></span>&#123;</div><div class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">　　　　　<span class="keyword">if</span> (event <span class="keyword">instanceof</span> demoEvent) &#123;</div><div class="line">　　　　　　　 DemoEvent demoEvent = (demoEvent)event;</div><div class="line">　　　　　　　 System.out.println(<span class="string">"name："</span> + demoEvent.getName());</div><div class="line">　　　　　　　 System.our.println(<span class="string">"password："</span> + demoEvent.getPassword());</div><div class="line">　　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　　 System.our.println(<span class="string">"容器本身事件："</span> + event);</div><div class="line">　　　　　&#125;</div><div class="line">　　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在xml中配置监听器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xubowei.DemoNotifier"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>Spring的配置扫描器可以自动将这个监听器加入监听器列表</p>
<p>然后测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</div><div class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">　　　　　ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</div><div class="line">　　　　　<span class="comment">//创建一个ApplicationEvent对象</span></div><div class="line">　　　　　DemoEvent event = <span class="keyword">new</span> DemoEvent(<span class="string">"123"</span>,<span class="string">"name"</span>,<span class="string">"password"</span>);</div><div class="line">　　　　　<span class="comment">//主动触发该事件</span></div><div class="line">　　　　　context.publishEvent(event);</div><div class="line">　　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-对象实例化与策略模式（Strategy）"><a href="#3-对象实例化与策略模式（Strategy）" class="headerlink" title="3. 对象实例化与策略模式（Strategy）"></a>3. 对象实例化与策略模式（Strategy）</h2><p>因为Java的静态特性，不能像动态语言（比如Python）那样自然的在运行时动态生成新的类型，所以为了解决这个问题，Java一般采用CGlib这个库来通过一些特殊方法实现动态对象。而在Spring框架中，大多数对象的生命周期都由IoC容器来管理，那么理所当然对象的初始化也由容器来完成，为了能够自如方便的切换对象生成方式，Spring使用了策略模式来解决这个问题：<br><figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/Strategy.png" alt="Strategy.png" title=""><figcaption class="figure__caption">Strategy.png</figcaption></figure></p>
<p>Spring通过在进行实例化获取正确的策略来初始化对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">		bean = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;getInstantiationStrategy().instantiate(bd, <span class="keyword">null</span>, parent),</div><div class="line">						getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		bean = getInstantiationStrategy().instantiate(bd, <span class="keyword">null</span>, parent);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="4-AOP与代理模式"><a href="#4-AOP与代理模式" class="headerlink" title="4. AOP与代理模式"></a>4. AOP与代理模式</h2><p><strong>面向侧面的程序设计</strong>（aspect-oriented programming，AOP，又译作<strong>面向方面的程序设计</strong>、<strong>观点导向编程</strong>、<strong>剖面导向程序设计</strong>），指的是一种程序设计范型，该范型以一种称为<strong>侧面</strong>（aspect，又译作<strong>方面</strong>）的语言构造为基础，<strong>侧面</strong>是一种新的模块化机制，用来描述分散在对象，类，函数的<strong>横切关注点</strong>（crosscutting concern）。</p>
<p>简单的来理解，就是通过一些手段，将很多代码中的重复代码以一种不增加系统耦合性的方法抽离出来复用；比如很多类都由记录日志的需要，但是这些记录日志的代码不好通过继承等面向对象的手段复用，因为可能这两个类没有任何关系，而如果通过抽象出公用的方法类的手段，就有可能导致这两个类依赖于那个工具类，这就增加了耦合度；AOP就是为了解决这种情况而生。</p>
<p>在Spring中，主要是通过代理模式来达到AOP的效果，通过Java注解标记需要插入切面的地方，然后集中编写切面插入的代码，然后底层可选的通过JDK动态代理或者CGlib动态生成代理类。</p>
<figure class="figure"><img src="/2017/12/14/简单聊聊Spring中几种设计模式/AOP.png" alt="AOP.png" title=""><figcaption class="figure__caption">AOP.png</figcaption></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2017/11/27/关于连续相同任意字符的正则匹配问题/">关于连续相同任意字符的正则匹配问题</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-11-27</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Leetcode/">Leetcode</a> <a class="article__tag-link" href="/tags/正则表达式/">正则表达式</a>
			</span>
		
	</div>

	

	
		<p>在做<strong>S10</strong>的时候，发现<code>.*</code>在进行正则匹配的时候是匹配的任意字符串，一开始可能思维出现了混乱认为其只能match像<strong>“aaaa”</strong>这样的连续相同字符，后来就想那如果确实想要匹配像”<strong>aaaa</strong>“这样的字符串，那要怎么办呢？</p>
<h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>如何使用正则匹配像<strong>“aaa”</strong>,<strong>“bbbbb”</strong>这样的字符串。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>想了想，可以通过捕获第一个字符，然后结合反向引用就可做到。</p>
<p>例子：</p>
<ol>
<li><code>(?&lt;char&gt;.)\k&lt;char&gt;*</code>   使用命名捕获组 </li>
</ol>
<ol>
<li><code>(.)\1*</code>  使用普通捕获组</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/lxcnn/article/details/4146148" target="_blank" rel="external">正则基础之——捕获组（capture group）</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/18/通过Hexo在github上建立静态博客/">通过Hexo在github上建立静态博客</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-18</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Hexo/">Hexo</a> <a class="article__tag-link" href="/tags/github/">github</a> <a class="article__tag-link" href="/tags/博客/">博客</a>
			</span>
		
	</div>

	

	
		<h2 id="首先进行必要的准备"><a href="#首先进行必要的准备" class="headerlink" title="首先进行必要的准备"></a>首先进行必要的准备</h2><h3 id="下载npm和node-js"><a href="#下载npm和node-js" class="headerlink" title="下载npm和node.js"></a>下载npm和node.js</h3><p>npm是node.js的包管理工具，因为hexo是基于node.js的，所以会在构建安装中用到node.js和npm。</p>
<p>因为是在macOS上进行配置，所以直接使用brew进行一键下载即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> brew install npm</div></pre></td></tr></table></figure>
<p>同时因为npm是基于node.js的，在安装npm的过程中，如果brew发现本地没有node.js，会自动进行node.js的安装.</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h3 id="创建博客文件夹"><a href="#创建博客文件夹" class="headerlink" title="创建博客文件夹"></a>创建博客文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo init &lt;blogname&gt;</div><div class="line"><span class="meta">$</span> cd &lt;blogname&gt;</div><div class="line"><span class="meta">$</span> npm install</div></pre></td></tr></table></figure>
<p>其中<code>&lt;blogname&gt;</code>指带的是你的博客源码的文件夹名，自己随意定义。</p>
<h3 id="与github进行deploy绑定"><a href="#与github进行deploy绑定" class="headerlink" title="与github进行deploy绑定"></a>与github进行deploy绑定</h3><h4 id="在github上创建博客仓库"><a href="#在github上创建博客仓库" class="headerlink" title="在github上创建博客仓库"></a>在github上创建博客仓库</h4><p>仓库名称符合<code>&lt;username&gt;</code>.github.io, 其中<code>&lt;username&gt;</code>为你的github用户名。</p>
<h4 id="更改本地-config-yml文件配置"><a href="#更改本地-config-yml文件配置" class="headerlink" title="更改本地_config.yml文件配置"></a>更改本地_config.yml文件配置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line"> type: git</div><div class="line"> repo: https://github.com/kpgoing/&lt;blog_repository_name&gt;.git</div><div class="line"> branch: master</div></pre></td></tr></table></figure>
<p>其中<code>&lt;blog_repository_name&gt;</code>使用自己的博客仓库名。</p>
<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>在<code>&lt;blogname&gt;</code>目录下，运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo clean</div><div class="line"><span class="meta">$</span> hexo g</div><div class="line"><span class="meta">$</span> hexo d</div></pre></td></tr></table></figure>
<p>则可在<code>&lt;blog_repository_name&gt;</code>查看初始blog.</p>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><p>我这里使用的<strong>melidu</strong>,功能较少，但是看起来还行。</p>
<p>在博客根目录，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git clone https://github.com/HoverBaum/meilidu-hexo.git themes/meilidu</div></pre></td></tr></table></figure>
<p>然后将<strong>config.yml</strong>配置进行更改:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">theme:</span> <span class="string">meilidu</span></div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h5 id="启用RSS"><a href="#启用RSS" class="headerlink" title="启用RSS"></a>启用RSS</h5><p>在博客根目录执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>
<p>安装RSS必要插件。</p>
<h5 id="启用Tags-paga"><a href="#启用Tags-paga" class="headerlink" title="启用Tags paga"></a>启用Tags paga</h5><p>在<strong>source</strong>目录下创建<strong>tags</strong>，在该目录下创建<strong>index.md</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: "Tags"</div><div class="line">layout: "tags"</div><div class="line">---</div></pre></td></tr></table></figure>
<h5 id="启用Categories-page"><a href="#启用Categories-page" class="headerlink" title="启用Categories page"></a>启用Categories page</h5><p>在<strong>source</strong>目录下创建<strong>categories</strong>，在该目录下创建<strong>index.md</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: "Categories"</div><div class="line">layout: "categories"</div><div class="line">---</div></pre></td></tr></table></figure>
<h5 id="启用About-page"><a href="#启用About-page" class="headerlink" title="启用About page"></a>启用About page</h5><p>在<strong>source</strong>目录下创建<strong>about</strong>，在该目录下创建<strong>index.md</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: About</div><div class="line">layout: page</div><div class="line">---</div><div class="line"></div><div class="line">自我介绍</div></pre></td></tr></table></figure>
<h5 id="更改header图片"><a href="#更改header图片" class="headerlink" title="更改header图片"></a>更改header图片</h5><p>将下列路径中的图片进行替换即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meilidu/source/img/header.jpg</div></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>可以通过模板创建post</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>hexo new post "article"</div></pre></td></tr></table></figure>
<p>这样可以在md中附加<strong>date</strong>和<strong>tag</strong>。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/18/准则/">准则</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-18</span><br />
		
		
	</div>

	

	
		<p>不做无意义的复制，不做无意义的收集</p>
<p>所有的都会附加思考，附加思想</p>
<p>做一个技术纯粹的人，在一个不纯粹的世界上</p>

	

	

</article>






	<span class="different-posts">📕 end of posts 📕</span>


	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />hope you have a nice day.</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2019 zhisheng | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
